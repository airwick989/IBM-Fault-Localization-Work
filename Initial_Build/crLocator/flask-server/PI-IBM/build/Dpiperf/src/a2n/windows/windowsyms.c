//**************************************************************************//
//                                                                          //
//                     Copyright (c) IBM Corporation 2001                   //
//                        Property of IBM Corporation                       //
//                            All Rights Reserved                           //
//                                                                          //
//                                                                          //
//                     Windows Symbol Harvester Mainline                    //
//                     ---------------------------------                    //
//                                                                          //
// REQUIRED functions:                                                      //
//  - GetHarvesterVersion()                                                 //
//  - GetSymbolsForModule()                                                 //
//  - ValidateKernelSymbols()                                               //
//**************************************************************************//
//
//
// Debug data formats:
// *******************
// COFF:     Not a Microsoft format. Documented. Well understood by A2N.
//           Exists either in the executable image or in a seprate file.
//           A2N harvests this format. Produces the highest quality symbols.
// CodeView: Microsoft format. Somewhat documented. Exists either in the
//           executable image on in a seprate file.
//           A2N uses the Microsoft symbol engine to harvest symbols.
// PDB:      Microsoft format. Undocumented. Exists only in a separate file.
//           A2N uses the Microsoft symbol engine to harvest symbols.
// SYM:      Data generated from MAP files. Exists only in a separate file.
//           Format not supported on >= WinNT. A2N uses the Microsoft symbol
//           engine to harvest symbols.
// MAP:      Generated by the linker. Exists only in a separate file.
//           A2N reads MAP files produced by Visual C++ 6.0. Maps yield
//           excellent symbol quality, equal to COFF/CodeView symbols.
//
//
// Microsoft symbol engine:
// ************************
//
// Microsoft, out of the goodness of their hearts, provides an engine to
// harvest symbols (all formats) from images and/or symbol files. The
// engine used to be implemented in IMAGEHLP.DLL (which was re-distributable).
// As of late, the engine is implemented in DBGHELP.DLL (which is also
// re-distributable).  Apparently IMAGEHLP gave away too much information
// Microsoft didn't want you and me to see. IMAGEHLP.DLL is no longer
// re-distributable.
// One important note: the symbol engine *NEVER* returns symbols,
// functions or variables, declared as "static".  It only returns
// symbols defined as "public".
//
//
// A2N handles the following types of "symbol" files:
// **************************************************
//
// DBG
// ---
//   DBG files contain the same debug information (COFF and CodeView)
//   that would normally be included in the image.  The information,
//   however, has been removed from the image (using REBASE.EXE) and
//   put into a DBG file.
//   In general the A2N harvester follows the same rules as the Microsoft
//   symbol engine (dbghelp.dll) when locating DBG symbol files.
//   The harvester uses the "searchpath" (either user supplied or a
//   a default one) and appends "\symbols" and "\dll" (for .dll) or
//   "\exe" (for .exe) or "\sys" (for .sys), etc., to each component
//   of the search path.
//   If "searchpath" is specified it overrides the default search order
//   and the harvester only uses the "searchpath" to look for symbol
//   files.
//   See "A2N symbol search order" below for A2N's search algorithm.
//
// PDB
// ---
//   PDB (Program Database File) is a Microsoft propietary debug format.
//   Its format/contents is not documented and the only way to access
//   information in the file is to use the Microsoft symbol engine
//   (aka. dbghelp.dll).
//   See "A2N symbol search order" below for A2N's search algorithm.
//   For PDB files the search order is different. The algorithm is
//   determined by the functionality of the Microsoft symbol engine.
//   By default, MSVC++ strips the symbols and places them in a separate
//   PDB file in the same directory as the executable.  The compiler
//   also stores the absolute path to the PDB file in the executable.
//   If the MS symbol engine can't find the PDB file in that location
//   then the symbol engine will locate the file using the same rules
//   used for locating DBG files.
//
// MAP
// ---
//   MAP files are plain text files produced by the linker. It contains
//   symbol information and layout of the executable image.
//   A2N uses the same search order as for DBG files.
//
// SYM
// ---
//   SYM files are typically generated from MAP files using MAPSYM.EXE.
//   They are another symbol data format. SYM files have deficiencies
//   in that they use a lot of 16-bit fields for counts which causes
//   problems with imaged containing lots (>16K) symbols.  SYM files are
//   not supported by Microsoft on Windows NT and later OS'.
//   A2N uses the same search order as for DBG files.
//
// EXPORTS
// -------
//   In the absence of any other symbols, and for DLL/SYS files, A2N will
//   harvest the Exported symbols.  They're not very high quality but they
//   may give enough information in cases where no other symbols are
//   available.
//
//
// A2N symbol search order
// ***********************
//
// In general the A2N harvester follows the same rules as the Microsoft
// symbol engine (dbghelp.dll) when locating symbol files.
// The harvester uses the "searchpath" (either user supplied or a
// a default one) and appends "\symbols" and "\dll" (for .dll) or
// "\exe" (for .exe) or "\sys" (for .sys), etc., to each component
// of the search path.
// If "searchpath" is specified it overrides the default search order
// and the harvester only uses the "searchpath" to look for symbol
// files.
// If no "searchpath" is specified then the harvester uses the following
// default search order:
// - Same directory as executable
// - %SystemRoot%\symbols\<dll | exe | sys>
// - Paths listed in the _NT_SYMBOL_PATH environment variable
// - Paths listed in the _NT_ALT_SYMBOL_PATH environment variable
// - Paths listed in the _NT_ALTERNATE_SYMBOL_PATH environment variable
//
// For PDB files the search order is different. The algorithm is
// determined by the functionality of the Microsoft symbol engine.
// By default, MSVC++ strips the symbols and places them in a separate
// PDB file in the same directory as the executable.  The compiler
// also stores the absolute path to the PDB file in the executable.
// If the MS symbol engine can't find the PDB file in that location
// then the symbol engine will locate the file using the same rules
// used for locating DBG files.
//
// Within each directory symbol files are searched in the following order:
// 1) DBG  (image_name.dbg)  (only if symbols stripped)
// 2) MAP  (image_name.map)
// 3) PDB  (image_name.pdb)  (only if symbols stripped)
//
// The search stops on the first symbol file match in any directory.
//
//
// To make life easier:
// ********************
// 1) Always place symbol files (whatever they might be) in the same
//    directory as the executable.
// 2) If that isn't possible then create a symbols directory and
//    place the files there, observing the naming conventions
//    dictated by Microsoft.  Set the  _NT_SYMBOL_PATH environment varible
//    accordingly.
//
//
// To obtain the best quality symbols: (1 is highest quality)
// ***********************************
// 1) Generate COFF symbols, either right in the executable
//    or split them into a DBG file using REBASE.EXE.
// 2) Generate MAP files.  Image does not need to have symbols.
// 3) If you need CodeView symbols (some debuggers need them)
//    then generate *BOTH* CodeView and COFF symbols, either
//    in the executable or split into a .DBG file.
// 4) If you need PDB symbols (or that is the only type you can
//    generate) then generate those.  A2N will use the MS symbol
//    engine and harvest whatever the symbol engine returns to
//    us.
// 5) If there are no symbols at all then A2N will harvest the
//    exported symbols (if any) from the image.
//
//
// Compiler/Linker flags required:
// *******************************
//                     Compiler                Linker
//                     ----------    ----------------------------------------
// COFF                -Zi or -Z7    -debug  -debugtype:COFF  -pdb:NONE
// CodeView            -Z7           -debug  -debugtype:CV    -pdb:NONE
// COFF and CodeView   -Z7           -debug  -debugtype:BOTH  -pdb:NONE
// PDB                 -Zi           -debug  -debugtype:CV    -pdb:"filename"
// COFF and PDB        -Zi           -debug  -debugtype:BOTH  -pdb:"filename"
//
//
// What the various DEBUG sections contain:
// ****************************************
// Link flags: -pdb:NONE -debugtype:COFF
//   * COFF symbols in image
//     - MISC section should contain the image name
//   * COFF symbols in DBG file (if REBASE used to strip symbols)
//     - MISC section should contain the name of the DBG fle
//
// Link flags: -pdb:NONE -debugtype:CV
//   * CodeView symbols in image
//     - MISC section should contain the image name
//
// Link flags: -pdb:NONE -debugtype:BOTH
//   * COFF and CodeView symbols in image
//     - MISC section should contain the image name
//
// Link flags: -pdb:fn   -debugtype:BOTH
//   * COFF symbols in image
//   * CodeView symbols in PDB file
//     - MISC section should contain the image name
//     - CODEVIEW section (+0x10) should contain the fully qualified
//       of PDB file containing the CV symbols.
//
// Link flags: -pdb:fn -debugtype:CV
//   * CodeView symbols in PDB file
//     - CODEVIEW section (+0x10) should contain the fully qualified
//       of PDB file containing the CV symbols.
//
// Link flags: -pdb:fn
//   * CodeView symbols in PDB file
//     - CODEVIEW section (+0x10) should contain the fully qualified
//       of PDB file containing the CV symbols.
//****************************************************************************
//
#include "a2nhdr.h"



//
// Externs (from a2n.c)
//
extern gv_t a2n_gv;                         // Globals


//
// Globals
//
IMAGE_DOS_HEADER *dh;                       // Image Dos Header (aka. mapped address)

SECTION_INFO sec[MAX_SECTIONS];             // Executable section information
int scnt = 0;                               // Total number of sections
int xcnt = 0;                               // Number of executable sections

ULONG img_misc_debug_dir_ts = 0;            // TimeDataStamp for MISC debug directory entry



//
// GetHarvesterVersion()
// *********************
//
// Returns Linux harverster version.
// Version is returned as an unsigned 32-bit quantity interpreted
// as follows:
//
//               3      2 2      1 1
//               1      4 3      6 5              0
//              +--------+--------+----------------+
//              | Major  |  Minor |    Revision    |
//              +--------+--------+----------------+
//               (0-255)  (0-255)     (0-65535)
//
// Returns
//    non-zero: Version information
//
uint GetHarvesterVersion(void)
{
   return ((uint)H_VERSION_NUMBER);
}


//
// ValidateKernelSymbols()
// ***********************
//
// Not needed in Windows but need to have it.
//
void ValidateKernelSymbols(void *lmn)
{
   return;
}


//
// GetSymbolsForModule()
// *********************
//
// Harvester interface.
// Given and executable module name (fully qualified) and an optional
// search path for locating symbol files associated with the module,
// this function will attempt to harvest symbols either from the
// executable itself or from an associated "symbol" file.
//
// Returns: 0 if *ANY* symbols are found anywhere
//          non-zero on errors
//
int GetSymbolsForModule(void *handle,            // Really a pointer to a Module node
                        char *modname,           // Fully qualified Module name
                        char *searchpath,        // Search path
                        uint64 loadaddr,         // Load virtual address
                        void *symbol_callback,   // Call-back function
                        void *section_callback)  // Call-back function
{
   CONTEXT_REC cr;
   int i, rc;
   MOD_NODE *mn;

   size_t filesize;                         // File size of image

   IMAGE_NT_HEADERS *nth = NULL;            // NT headers
   IMAGE_FILE_HEADER *ifh = NULL;           // Image file header
   IMAGE_OPTIONAL_HEADER *ioh = NULL;       // Image optional header
   IMAGE_EXPORT_DIRECTORY *ied = NULL;      // Image export directory
   IMAGE_DEBUG_DIRECTORY *idd = NULL;       // Image debug directory
   int debug_dir_cnt;                       // Number of debug directory entries
   IMAGE_DEBUG_MISC *idm = NULL;            // MISC Debug section
   IMAGE_CV_HEADER *cvh = NULL;             // CODEVIEW Debug section header
   IMAGE_SECTION_HEADER *ish = NULL;        // Image section headers
   IMAGE_COFF_SYMBOLS_HEADER *ich = NULL;   // File address of COFF Symbols header
   IMAGE_DATA_DIRECTORY *ioh_DataDirectory;

   void *idots = NULL;                      // OMAP_TO_SRC debug information
   void *idofs = NULL;                      // OMAP_FROM_SRC debug information

   char idir[MAX_PATH_LEN];                 // Image path (without filename)
   char ifn[MAX_FILENAME_LEN];              // Image filename (without path, without extension)
   char iext[16];                           // Image extension (without dot)
   char local_searchpath[(2 * MAX_PATH_LEN)];   // Where we'll look for symbol files
   char updated_searchpath[(2 * MAX_PATH_LEN)]; // Where we'll look for symbol files
   char sname[MAX_PATH_LEN];                   // Next symbol file name
   char *c, *pc, *pname;

   char sym_ext[4][6];                      // Symbol file extensions to look for
   PFN_FILE_HARVESTER sym_ext_handler[4];   // Symbol harvester for given extension
   int sym_ext_cnt = 0;

   int sec_cnt;                             // Total number of sections
   int executable_section;                  // 1=section is executable



   dbghv(("> GetSymbolsForModule: handle=0x%p, name='%s', searchpath='%s' (%d)\n",
          handle, modname, searchpath, strlen(searchpath)));
   dbghv(("                       loadaddr=0x%"_LZ64X", symcallbak=0x%p, seccallback=0x%p\n",
          loadaddr, symbol_callback, section_callback));
   //
   // Context saved here and used by the real callback function
   //
   cr.handle = handle;
   cr.load_addr = loadaddr;
   cr.imgname = modname;
   cr.searchpath = searchpath;
   cr.symtype = 0;
   cr.hflags = 0;
#if defined(_64BIT)
#pragma warning(disable : 4055)
// Win64 compiler bitches about casting the function pointers to the right types
#endif
   cr.symbol_callback = (PFN_SYMBOL_CALLBACK)symbol_callback;
   cr.section_callback = (PFN_SECTION_CALLBACK)section_callback;
#if defined(_64BIT)
#pragma warning(default : 4055)
#endif

   mn = (MOD_NODE *)handle;

   //
   // Globals initialization
   //
   scnt = xcnt = 0;
   dh = NULL;

   //
   // Make sure module exists and we can read it.
   // This is an absolute requirement!  We have to be able to read the image.
   //
   if (!FileIsReadable(modname)) {
      errmsg(("*E* GetSymbolsForModule: unable to access '%s'\n",modname));
      rc = A2N_FILE_NOT_FOUND_OR_CANT_READ;
      goto TheEnd;
   }

   //
   // Map file so we can look at the header
   //
   dh = (IMAGE_DOS_HEADER *)MapFile(modname, &filesize);
   if (dh == NULL) {
      errmsg(("*E* GetSymbolsForModule: unable to map file '%s'.\n",modname));
      rc = A2N_FILE_NOT_FOUND_OR_CANT_READ;
      goto TheEnd;
   }
   if (IsBadReadPtr((void *)dh, sizeof(IMAGE_DOS_HEADER))) {
      errmsg(("*E* GetSymbolsForModule: IMAGE_DOS_HEADER for %s is not readable.\n",modname));
      rc = A2N_FILE_NOT_FOUND_OR_CANT_READ;
      goto TheEnd;
   }
   cr.mod_addr = (void *)dh;

   //
   // Determine image type.
   // Being a Windows world, we only handle PE images.
   //
   rc = GetModuleType(dh);
   if (rc != MODULE_TYPE_PE) {
      errmsg(("*E* GetSymbolsForModule: module is not PE format.\n"));
      rc = A2N_INVALID_MODULE_TYPE;
      goto TheEnd;
   }
   mn->type = rc;                           // Set module type for now

   //
   // PE image. Check to see if we even want to use it.
   //
   if (!ModuleIsOkToUse(mn->ts, mn->chksum, filesize)) {
      errmsg(("*E* GetSymbolsForModule: module '%s' is NOT OK to use\n",modname));
      rc = A2N_INVALID_MODULE_TYPE;
      goto TheEnd;
   }

   //
   // We know we're looking at a valid image. It may or may not have
   // symbols but we don't know that yet.
   //
   // Set up addressability to the various headers ...
   //
   nth = (IMAGE_NT_HEADERS *)PtrAdd(dh, dh->e_lfanew);  // NT Header
   ifh = &(nth->FileHeader);                            // Image file header
   ioh = &(nth->OptionalHeader);                        // Image optional header

   //
   // Save the timestamp and checksum of the on-disk image in the context record
   //
   cr.img_ts = ifh->TimeDateStamp;
   cr.img_cs = GetIohCheckSum(ioh);

   //
   // Enumerate the image sections and gather code (for executable
   // sections only) if required. We want to gather code even if the
   // symbols don't come from the on-disk image.
   //
   sec_cnt = EnumerateSections(&cr);
   if (sec_cnt == 0) {
      errmsg(("*E* GetSymbolsForModule: module has no sections!\n"));
      rc = A2N_INVALID_MODULE_TYPE;
      goto TheEnd;
   }

   //
   // Find and dump the EXPORT directory if a dll
   //
   if (ifh->Characteristics & IMAGE_FILE_DLL) {
      ied = FindExportDirectory(nth, NULL, NULL, NULL);
      if (ied != NULL)
         DumpExportDirectoryTable(ied);
   }

   //
   // Check all debug directories and see what kind of debug information we have
   //
   idd = FindDebugDirectory();
   if (idd == NULL) {
      dbghv(("- GetSymbolsForModule: *W* debug data directory not present. Trying other things ...\n"));
      goto TryToFindSymbolFile;
   }
   ioh_DataDirectory = GetIohDataDirectory(ioh);
   debug_dir_cnt = ioh_DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size / sizeof(IMAGE_DEBUG_DIRECTORY);

   if (IsBadReadPtr((void *)idd, (sizeof(IMAGE_DEBUG_DIRECTORY) * debug_dir_cnt))) {
      errmsg(("*E* GetSymbolsForModule: IMAGE_DEBUG_DIRECTORYs for %d entries are not readable.\n",debug_dir_cnt));
      rc = A2N_FILE_NOT_FOUND_OR_CANT_READ;
      goto TheEnd;
   }
   DumpDebugDirectories(idd, debug_dir_cnt);

   //
   // Set whether 32 or 64-bit EXE/DLL
   //
   if (GetIohMagic(ioh) == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
      mn->flags |= A2N_FLAGS_64BIT_MODULE;  // PE32+ (64-bit) module
   else
      mn->flags |= A2N_FLAGS_32BIT_MODULE;  // PE32  (32-bit) module

   //
   // Make sure the first debug directory entry is of a known type and good.
   //
   if (idd[0].Type > IMAGE_DEBUG_TYPE_CLSID) {
      errmsg(("*E* GetSymbolsForModule: %s DEBUG_DIRECTORY[0] Type is not valid. Type=%d.\n",modname,idd[0].Type));
      goto TryToFindSymbolFile;
   }
   if (idd[0].Characteristics != 0) {
      errmsg(("*E* GetSymbolsForModule: %s DEBUG_DIRECTORY[0] Characteristics non-zero. Characteristics=0x%08X.\n",modname,idd[0].Characteristics));
      goto TryToFindSymbolFile;
   }

   //
   // Process the debug directories and grab the ones we want
   //
   for (i = 0; i < debug_dir_cnt; i++) {
      if (idd[i].Type == IMAGE_DEBUG_TYPE_COFF) {
         // Have COFF debug symbols. Remember it.
         ich = (IMAGE_COFF_SYMBOLS_HEADER *)PtrAdd(dh, idd[i].PointerToRawData);
      }
      if (idd[i].Type == IMAGE_DEBUG_TYPE_MISC) {
         // Have MISC debug directory.  Remember it.
         idm = (IMAGE_DEBUG_MISC *)PtrAdd(dh, idd[i].PointerToRawData);
         img_misc_debug_dir_ts = idd[i].TimeDateStamp;
         DumpMiscDebugSection(idm);
      }
      if (idd[i].Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
         // Have CODEVIEW debug directory.  Remember it.
         cvh = (IMAGE_CV_HEADER *)PtrAdd(dh, idd[i].PointerToRawData);
      }
      if (idd[i].Type == IMAGE_DEBUG_TYPE_OMAP_TO_SRC) {
         // Have OMAP_TO_SRC information. Remember it.
         idots = (void *)PtrAdd(dh, idd[i].PointerToRawData);
         dbghv(("- GetSymbolsForModule: OMAP_TO_SRC debug section: %p\n",idots));
      }
      if (idd[i].Type == IMAGE_DEBUG_TYPE_OMAP_FROM_SRC) {
         // Have OMAP_FROM_SRC information. Remember it.
         idofs = (void *)PtrAdd(dh, idd[i].PointerToRawData);
         dbghv(("- GetSymbolsForModule: OMAP_FROM_SRC debug section: %p\n",idofs));
      }
   }

   //
   // Have MISC debug directory.
   //
// if (idm != NULL) {
//    //##### What do I need to do with this data?
//    //##### If symbols in exe/dll then it should be the image name
//    //##### If symbols stripped to DBG file it should be the DBG file name
//    //##### If PDB symbols it should be the PDB file name
//    if (idm->DataType == IMAGE_DEBUG_MISC_EXENAME) {
//       dbghv(("- GetSymboForModule: misc->Data: %s\n",idm->Data));
//    }
//
//    if (ich == NULL && cvh == NULL) {
//       //
//       // If there is no COFF and no CV debug directory entry then
//       // img_misc_debug_dir_ts should be checked against the IMAGE_SEPARATE_DEBUG_HEADER
//       // timestamp in addition to the image timestamp. If either img_misc_debug_dir_ts
//       // or mn-ts matches IMAGE_SEPARATE_DEBUG_HEADER->TimeDateStamp then we'll
//       // assume the DBG file is OK and matches the image.
//    }
// }

   //
   // See if we only want exports and do only them ...
   //
   if (G(harvest_exports_only)) {
      goto TryExports;                      // Just do exports!
   }

   //
   // If the image contains COFF debug symbols then go read them ...
   //
   //##### On errors or no symbols I could just try to find symbols in all
   //##### the files I know how to handle, in the best order, and try exports
   //##### as the last resort.
   //##### All I need to do is: goto TryToFindSymbolFile;
   //
   //
   if (ich != NULL) {
      cr.mod_addr = (void *)dh;
      cr.symtype = (int)SYMBOL_TYPE_FUNCTION;

      dbghv(("- GetSymbolsForModule: attempting to get COFF symbols from image\n"));
      rc = HarvestCoffSymbols(ich, &cr);
      if (rc == 0) {
         dbghv(("- GetSymbolsForModule: no COFF symbols or error. Trying other symbol formats ...\n"));
//E      goto TryExports;                   // Last resort
//E      goto TryMsHarvester;
         goto TryToFindSymbolFile;
      }
      else {
         rc = 0;
         mn->hvname = strdup(modname);      // Symbols came from here
         goto TheEnd;
      }
   }

   //
   // If the image contains CodeView debug symbols then go read them ...
   // An image whose symbols have been stripped to a PDB file will appear
   // to have CodeView symbols, but the CV_HEADER signature (NB10 or RSDS)
   // will indicate that the symbols are in a PDB file.
   //
   //##### On all of these I could just try to find symbols in all the files
   //##### I know how to handle, in the best order, and try exports as the
   //##### last resort.
   //##### All I need to do is: goto TryToFindSymbolFile;
   //
   if (cvh != NULL) {
      cr.mod_addr = (void *)dh;
      cr.symtype = (int)SYMBOL_TYPE_FUNCTION;

      dbghv(("- GetSymbolsForModule: attempting to get CV symbols from image\n"));
      rc = HarvestCodeViewSymbols(cvh, &cr);
      if (rc == 0) {
         dbghv(("- GetSymbolsForModule: no CodeView symbols or error. Trying other symbol formats ...\n"));
//E      goto TryExports;                   // Last resort
//E      goto TryMsHarvester;
         goto TryToFindSymbolFile;
      }
      else if (rc == -1) {
         dbghv(("- GetSymbolsForModule: CV symbols in PDB file. Trying other symbol formats ...\n"));
//E      strcpy(sym_ext[0], ".pdb");
//E      sym_ext_handler[0] = GetSymbolsFromPdbFile;
//E      sym_ext_cnt = 1;
//E      goto FindAlongSearchPath;
//E      goto TryMsHarvester;
         goto TryToFindSymbolFile;
      }
      else if (rc == -2) {
         dbghv(("- GetSymbolsForModule: Unknown CV symbols format. Trying other symbol formats ...\n"));
//E      goto TryExports;                   // Last resort
//E      goto TryMsHarvester;
         goto TryToFindSymbolFile;
      }
      else {
         rc = 0;
         mn->hvname = strdup(modname);      // Symbols came from here
         goto TheEnd;
      }

   }

   //
   // If symbols stripped (ifh->Characteristics & IMAGE_FILE_DEBUG_STRIPPED)
   // or if the image does not contain symbols then try to find symbols
   // associated with the image elsewhere and harvest them if possible.
   //
   // * If the image indicates that there was/is no debug information then
   //   we will only look for MAP files.
   // * If the image indicates that debug information was stripped then we
   //   will look for DBG and PDB files in addition to MAP files.
   //
   // In order to validate the symbol file (whatever it is) we need the
   // timestamp from the image, *NOT* the one stored in the module node.
   // The one in the module node could be zero and thus we'd never be able
   // to match the symbol file to the image. The image always has a good
   // timestamp.
   //
   // ***** Don't look for PDB files unless there are no MAP and no DBG files.
   //
TryToFindSymbolFile:

   strcpy(sym_ext[0], ".dbg");
   sym_ext_handler[0] = GetSymbolsFromDbgFile;
   strcpy(sym_ext[1], ".map");
   sym_ext_handler[1] = GetSymbolsFromMapFile;
   strcpy(sym_ext[2], ".jmap");
   sym_ext_handler[2] = GetSymbolsFromJmapFile;
   strcpy(sym_ext[3], ".pdb");
// sym_ext_handler[3] = GetSymbolsFromPdbFile;
   sym_ext_handler[3] = NULL;
// sym_ext_cnt = 4;
   sym_ext_cnt = 3;

//E FindAlongSearchPath:
   //
   // Build some strings we're going to need in a minute ...
   // - ifn:  Image file name without path or extension.  Basically the
   //         thing after the last "\" and before the last "."
   // - iext: Image file extension.  Basically the thing after the last "."
   // - idir: Image directory. Basically the thing before the last "\"
   //
   c = GetFilenameFromPath(modname);
   if (c == NULL) {
      errmsg(("*E* GetSymbolsForModule: unable to isolate image filename!\n"));
      rc = NO_SYMBOLS_FOUND;
      goto TheEnd;                          // Bail out
   }
   strcpy(ifn, c);                          // Only the image file name (no path)

   c = strrchr(ifn,'.');                    // Look for last '.'
   if (c == NULL) {
      errmsg(("*E* GetSymbolsForModule: unable to isolate image filename extension!\n"));
      rc = NO_SYMBOLS_FOUND;
      goto TheEnd;                          // Bail out
   }

   *c = 0;                                  // Zap off the extension from the filename
   strcpy(iext, ++c);                       // Keep the image file name extension

   strcpy(idir, modname);                   // Make copy of modname
   c = strrchr(idir,G(PathSeparator));      // Look for last '\'
   if (c == NULL)
      strcpy(idir,".");                     // No directory - assume "."
   else
      *c = 0;                               // Zap off filename

   dbghv(("- GetSymbolsForModule: idir= '%s' ifn='%s' iext='%s'\n",idir,ifn,iext));

   //
   // Always set the image path as the very first path in the search path.
   // The MS harvester will use it if we give it to him.
   //
   strcpy(updated_searchpath, idir);
   strcat(updated_searchpath, ";");
   strcat(updated_searchpath, searchpath);
// cr.searchpath = updated_searchpath;      // Use this search path
   dbghv(("- GetSymbolsForModule: updated search path = '%s'\n",updated_searchpath));

   //
   // OK, first thing is see if the symbols for this image are in the
   // jvmmap file (if we have one).
   //
   rc = GetSymbolsFromJvmmapFile(&cr);
   if (rc > 0) {
      // mn->hvname and mn->flags already set
      rc = 0;
      goto TheEnd;
   }

   //
   // Next is to look for symbol files in each directory in the search path.
   // Make local copy of searchpath (strtok mucks with it).
   //
   pname = sname;                           // Assume symbols coming from another file
   strcpy(local_searchpath, updated_searchpath);

   //
   // Now look for whatever symbol types we've decided upon in
   // each component of local_searchpath.  We stop on the first
   // hit.
   //
   pc = strtok(local_searchpath, G(SearchPathSeparator_str));   // Prime strtok
   while(pc) {
      //
      // Look for symbol file in the base directory
      //
      for (i = 0; i < sym_ext_cnt; i++) {
         strcpy(sname, pc);                    // path
         strcat(sname, G(PathSeparator_str));  // '\'
         strcat(sname, ifn);                   // filename (without extension)
         strcat(sname, sym_ext[i]);

         if (!FileIsReadable(sname)) {
            dbghv(("- GetSymbolsForModule: '%s' does not exist. Continuing ...\n",sname));
            continue;
         }

         if (sym_ext_handler[i] == NULL) {
            // Don't do any processing!
            dbghv(("- GetSymbolsForModule: '%s' *** exists but will not be processed now ***\n",sname));
            continue;
         }
         else {
            // Process this one
            dbghv(("- GetSymbolsForModule: trying '%s' ...\n",sname));

            // Call symbol harvester
            rc = sym_ext_handler[i](sname, ifh->TimeDateStamp, &cr);

            if (rc > 0) {
               rc = 0;
               if (mn->hvname == NULL) {
                  // Symbol harvester hasn't already set the name
                  mn->hvname = strdup(sname);                     // Symbols came from here
                  mn->flags |= A2N_FLAGS_SYMBOLS_NOT_FROM_IMAGE;  // and it's not the on-disk image
               }
               goto TheEnd;
            }
         }
      }

      //
      // Now look in the base directory\extension directory
      //
      for (i = 0; i < sym_ext_cnt; i++) {
         strcpy(sname, pc);                    // path
         strcat(sname, G(PathSeparator_str));  // '\'
         strcat(sname, iext);                  // extension
         strcat(sname, G(PathSeparator_str));  // '\'
         strcat(sname, ifn);                   // filename (without extension)
         strcat(sname, sym_ext[i]);

         if (!FileIsReadable(sname)) {
            dbghv(("- GetSymbolsForModule: '%s' does not exist. Continuing ...\n",sname));
            continue;
         }

         if (sym_ext_handler[i] == NULL) {
            // Don't do any processing!
            dbghv(("- GetSymbolsForModule: '%s' *** exists but will not be processed now ***\n",sname));
         }
         else {
            // Process this one
            dbghv(("- GetSymbolsForModule: trying '%s' ...\n",sname));

            // Call symbol harvester
            rc = sym_ext_handler[i](sname, ifh->TimeDateStamp, &cr);

            if (rc > 0) {
               rc = 0;
               if (mn->hvname == NULL) {
                  // Symbol harvester hasn't already set the name
                  mn->hvname = strdup(sname);                     // Symbols came from here
                  mn->flags |= A2N_FLAGS_SYMBOLS_NOT_FROM_IMAGE;  // and it's not the on-disk image
               }
               goto TheEnd;
            }
         }
      }

      //
      // If we fall thru to here we did not find symbols/symbol files
      // in this search path component.  Try the next one ...
      //
      pc = strtok(NULL, G(SearchPathSeparator_str));
   }

   //
   // If we fall thru to here we did not find symbols anywhere.
   //
   dbghv(("- GetSymbolsForModule: No symbols anywhere. Trying DbgHelp ...\n"));

//E TryMsHarvester:
   //
   // Fell thru and didn't find any debug formats we understood
   // so let the MS symbol engine try.  If nothing else it will give
   // us the Exports (in DLLs).
   //
   dbghv(("- GetSymbolsForModule: trying the MS symbol engine ...\n"));
   cr.searchpath = updated_searchpath;      // Use this search path which includes the
                                            // directory where the image is.
   rc = GetSymbolsUsingMsEngine(&cr);
   if (rc == 0) {
      dbghv(("- GetSymbolsForModule: No symbols found by DbgHelp. Trying EXPORTS ...\n"));
      goto TryExports;                      // Grab the exports ourselves if we can
   }
   else {
      rc = 0;
//    mn->hvname = strdup(modname);         // Symbols came from here ??????
      goto TheEnd;
   }

TryExports:
   //
   // This is really the last attempt at getting some symbols.  We'll look
   // in the image and try to harvest the exports if we can, if we want to,
   // and if the user wants them.
   //
   if (G(symbol_quality) == MODE_GOOD_SYMBOLS && G(always_harvest) == 0) {
      dbghv(("- GetSymbolsForModule: About to look for exports but user doesn't want them.\n"));
      rc = NO_SYMBOLS_FOUND;
      goto TheEnd;
   }

   rc = HarvestExportSymbols(nth, &cr);
   if (rc == 0) {
      dbghv(("- GetSymbolsForModule: no EXPORTed symbols or error. Giving up ...\n"));
      rc = NO_SYMBOLS_FOUND;
      goto TheEnd;                       // I know, I know ...
   }
   else {
      rc = 0;
      mn->type = MODULE_TYPE_PE;
      mn->hvname = strdup(modname);      // Symbols came from here
      goto TheEnd;                       // I know, I know ...
   }

TheEnd:
   //
   // Send back all the sections.
   // Waited until now because it is possible to harvest code *AFTER*
   // the sections are enumerated initially and we want to make sure
   // we send back sections with all the code we've gathered.
   // We may or may not have any symbols.
   //
   for (i = 0; i < scnt; i++) {
      if (sec[i].flags & IMAGE_SCN_MEM_EXECUTE)
         executable_section = 1;
      else
         executable_section = 0;

      SendBackSection(sec[i].name,          // Section name
                      sec[i].number,        // Section number
                      sec[i].start_addr,    // Section start address/offset
                      sec[i].offset,        // Section offset
                      sec[i].size,          // Section size
                      sec[i].flags,         // Section flags
                      sec[i].loc_addr,      // Where I have it loaded
                      executable_section,   // Executable section or not
                      &cr);                 // Context record

#if defined(_IA64)
      //
      // Send send back a fake symbol for the beginning of the .text
      // section. This will be used as the "ILT".
      //
      if (stricmp(sec[i].name,".text") == 0) {
         if (mn->symcnt == 0)
            mn->flags |= A2N_FLAGS_ILT_SYMBOLS_ONLY;  // Only symbol(s) is(are) ILTs

         SendBackSymbol(A2N_SYMBOL_ILT_STR, // Symbol name
                        sec[i].offset,      // Symbol offset
                        0,                  // Symbol size (0 so we force calculation)
                        SYMBOL_TYPE_PE_ILT, // Symbol type (ILT, or so we guess)
                        sec[i].number,      // Section to which the symbol belongs
                        sec[i].loc_addr,    // Code associated with this symbol
                        &cr);               // Context record

      }
#endif
   }

   UnmapFile(dh);                           // Unmap image

   dbghv(("< GetSymbolsForModule rc=%d\n",rc));
   return (rc);
}


//
// SendBackSymbol()
// ****************
//
// Actual callback function invoked by the harvester for each symbol.
// Can be used to "filter" or pre-process symbols before actually
// handing them back to the requestor.
// Returns: 0 to allow harvester to continue
//          non-zero to force harvester to stop
//
int SendBackSymbol(char *symbol_name,       // Symbol name
                   uint symbol_offset,      // Symbol offset
                   uint symbol_size,        // Symbol size
                   int symbol_type,         // Symbol type (label, export, etc.)
                   int section,             // Section to which the symbol belongs
                   char *code,              // Code associated with this symbol
                   void *context)           // Context record
{
   SYMBOL_REC sr;
   CONTEXT_REC *cr = (CONTEXT_REC *)context;
   PFN_SYMBOL_CALLBACK UserSymbolCallBack = cr->symbol_callback;
   int rc = 0;

   if (UserSymbolCallBack != NULL) {
      sr.name = symbol_name;
      sr.offset = symbol_offset;
      sr.length = symbol_size;
      sr.type = symbol_type;
      sr.section = section;
      sr.code = code;
      sr.handle = cr->handle;
      rc = UserSymbolCallBack(&sr);            // Call user callback function
   }
   return (rc);
}


//
// SendBackSection()
// *****************
//
// Actual callback function invoked by the harvester for each section.
// Can be used to "filter" or pre-process sections before actually
// handing them back to the requestor.
// Returns: 0 to allow harvester to continue
//          non-zero to force harvester to stop
//
static int SendBackSection(char *section_name,        // Section name
                           int section_number,        // Section number
                           uint64 start_addr,         // Section start address/offset
                           uint section_offset,       // Section offset
                           uint section_size,         // Section size
                           uint section_flags,        // Section flags
                           void *loc_addr,            // Where I have it loaded
                           int executable,            // Executable section or not
                           void *context)             // Context record
{
   SECTION_REC sr;
   CONTEXT_REC *cr = (CONTEXT_REC *)context;
   PFN_SECTION_CALLBACK UserSectionCallBack = cr->section_callback;
   char temp_name[9];
   int rc = 0;

   if (UserSectionCallBack != NULL) {
      if (section_name[7] != '\0') {
         //
         // Handle section names that are exactly 8 characters
         //
         memcpy(temp_name, section_name, 8);
         temp_name[8] = 0;                  // Section name was exactly 8 bytes
         sr.name = temp_name;
      }
      else {
         sr.name = section_name;
      }

      sr.number = section_number;
      sr.executable = executable;
      sr.start_addr = start_addr;
      sr.asec = NULL;                       // Linux-only for now ...
      sr.offset = section_offset;
      sr.size = section_size;
      sr.flags = section_flags;
      sr.loc_addr = loc_addr;
      sr.handle = cr->handle;
      rc = UserSectionCallBack(&sr);        // Call user callback function
   }
   return (rc);
}


//
// GetIohMagic()
// *************
//
ushort GetIohMagic(IMAGE_OPTIONAL_HEADER *ioh)
{
   return (ioh->Magic);
}


//
// GetIohCheckSum()
// ****************
//
uint GetIohCheckSum(IMAGE_OPTIONAL_HEADER *ioh)
{
   if (GetIohMagic(ioh) == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
      return (((IMAGE_OPTIONAL_HEADER32 *)ioh)->CheckSum);
   else
      return (((IMAGE_OPTIONAL_HEADER64 *)ioh)->CheckSum);
}


//
// GetIohDataDirectory()
// *********************
//
IMAGE_DATA_DIRECTORY *GetIohDataDirectory(IMAGE_OPTIONAL_HEADER *ioh)
{
   if (GetIohMagic(ioh) == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
      return (((IMAGE_OPTIONAL_HEADER32 *)ioh)->DataDirectory);
   else
      return (((IMAGE_OPTIONAL_HEADER64 *)ioh)->DataDirectory);
}


//
// GetIohNumberOfRvaAndSizes()
// ***************************
//
uint GetIohNumberOfRvaAndSizes(IMAGE_OPTIONAL_HEADER *ioh)
{
   if (GetIohMagic(ioh) == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
      return (((IMAGE_OPTIONAL_HEADER32 *)ioh)->NumberOfRvaAndSizes);
   else
      return (((IMAGE_OPTIONAL_HEADER64 *)ioh)->NumberOfRvaAndSizes);
}


//
// ModuleIsOkToUse()
// *****************
//
// Returns: TRUE if OK to use module
//          FALSE otherwise
//
static bool_t ModuleIsOkToUse(uint ts, uint chksum, size_t filesize)
{
   IMAGE_NT_HEADERS *nth = NULL;            // NT headers
   IMAGE_FILE_HEADER *ifh = NULL;           // Image file header
   IMAGE_OPTIONAL_HEADER *ioh = NULL;       // Image optional header
   uint ioh_CheckSum;
   ushort ioh_Magic;



   dbghv(("> ModuleIsOkToUse: dh=0x%p\n",dh));

   __try {
      //
      // Set up addressability to the various headers
      //
      nth = (IMAGE_NT_HEADERS *)PtrAdd(dh, dh->e_lfanew);  // NT Header
      if (IsBadReadPtr((void *)dh, sizeof(IMAGE_DOS_HEADER))) {
         errmsg(("*E* ModuleIsOkToUse: IMAGE_NT_HEADERS is not readable.\n"));
         return (FALSE);
      }

      ifh = &(nth->FileHeader);                            // Image file header
      ioh = &(nth->OptionalHeader);                        // Image optional header
      DumpNtHeader(nth);

      //
      // Images *MUST* have an Optional Header
      //
      if (ifh->SizeOfOptionalHeader == 0) {
         errmsg(("*E* ModuleIsOkToUse: module does not have an OPTIONAL_HEADER\n"));
         return (FALSE);
      }

      //
      // Now snoop around in the PE header a bit ...
      // Image must:
      // - be executable
      // - be runable on this machine (IA64 can run IA32 executables)
      // - timestamp must match the one we have
      // - checksum must match the one we have
      //
      if ((ifh->Characteristics & IMAGE_FILE_EXECUTABLE_IMAGE) == 0) {
         errmsg(("*E* ModuleIsOkToUse: Image is not executable\n"));
         return (FALSE);
      }

      if (ifh->Machine != IMAGE_FILE_MACHINE_IA64 &&
          ifh->Machine != IMAGE_FILE_MACHINE_AMD64 &&
          ifh->Machine != IMAGE_FILE_MACHINE_I386) {
         errmsg(("*E* ModuleIsOkToUse: ifh->Machine incorrect. Not I386, IA64 nor AMD64. Got 0x%04x\n",ifh->Machine));
         return (FALSE);
      }

      ioh_Magic = GetIohMagic(ioh);
      if (ioh_Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC &&
          ioh_Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
         errmsg(("*E* ModuleIsOkToUse: ioh->Magic incorrect. Not PE32 nor PE32+. Got 0x%04x\n",ioh_Magic));
         return (FALSE);
      }

      if (ts != 0) {                           // If we have it, make sure timestamp matches
         //
         // We always do this check and can't override it: we cannot use an
         // image whose TS doesn't match because it's not the same image that
         // was executing.
         //
         if (ts != ifh->TimeDateStamp) {
            if (G(ignore_ts_cs)) {
               warnmsg(("*W* ModuleIsOkToUse: module timestamp mismatch: %08x vs %08x\n", ifh->TimeDateStamp, ts));
               warnmsg(("    - Using anyway because A2N_IGNORE_TSCS is set.\n"));
               return (TRUE);
            }
            else {
               errmsg(("*E* ModuleIsOkToUse: module timestamp mismatch: %08x vs %08x\n", ifh->TimeDateStamp, ts));
               errmsg(("    - ts 0x%08x is: %s",ifh->TimeDateStamp, TsToDate(ifh->TimeDateStamp)));
               errmsg(("    - ts 0x%08x is: %s",ts, TsToDate(ts)));
               return (FALSE);
            }
         }
      }

      if (chksum != 0) {                       // If we have it, make sure checksum matches
         ioh_CheckSum = GetIohCheckSum(ioh);
         if (chksum != ioh_CheckSum) {
            if (G(ignore_ts_cs)) {
               warnmsg(("*W* ModuleIsOkToUse: module cheksum mismatch: %08x vs %08x\n", ioh_CheckSum, chksum));
               warnmsg(("    - Using anyway because A2N_IGNORE_TSCS is set.\n"));
               return (TRUE);
            }
            else {
               errmsg(("*E* ModuleIsOkToUse: module cheksum mismatch: %08x vs %08x\n", ioh_CheckSum, chksum));
               return (FALSE);
            }
         }
      }

      //
      // Module OK to use so far ...
      //
      dbghv(("< ModuleIsOkToUse: YES\n"));
      return (TRUE);
   }
   __except (EXCEPTION_EXECUTE_HANDLER) {
      // Handle access violations
      msg_log("\n**WARNING** ##### EXCEPTION 0x%X in ModuleIsOkToUse #####\n",_exception_code());
      return (FALSE);
   }
}


//
// EnumerateSections()
// *******************
//
// Builds the global "sec" array and sets globals "scnt" and "xcnt"
//
// Returns: number of sections if successfull
//          0 otherwise
//
static int EnumerateSections(CONTEXT_REC *cr)
{
   IMAGE_NT_HEADERS *nth;                   // NT headers
   IMAGE_FILE_HEADER *ifh;                  // Image file header
   IMAGE_SECTION_HEADER *ish;               // Image section headers
   int i;


   dbghv(("> EnumerateSections: dh=0x%p, cr=0x%p\n",dh,cr));
   //
   // Set up addressability to the various headers
   //
   nth = (IMAGE_NT_HEADERS *)PtrAdd(dh, dh->e_lfanew);  // NT Header
   ifh = &(nth->FileHeader);                            // Image file header
   ish = IMAGE_FIRST_SECTION(nth);          // Immediately following Optional header

   //
   // Make sure we can handle all the sections in this image
   //
   if (ifh->NumberOfSections > MAX_SECTIONS) {
      errmsg(("*E* EnumerateSections: ***** INTERNAL ERROR: %d > section table dimemsion of %d!\n",
              ifh->NumberOfSections, MAX_SECTIONS));
      return (0);                           // No sections
   }

   //
   // Make sure the SECTION_HEADERs are accessible for all sections
   //
   if (IsBadReadPtr((void *)ish, (sizeof(IMAGE_SECTION_HEADER) * ifh->NumberOfSections))) {
      errmsg(("*E* EnumerateSections: IMAGE_SECTION_HEADERs for %d sections is not readable.\n",ifh->NumberOfSections));
      scnt = 0;                          // Force 0 sections!
      return (0);
   }
   DumpSectionHeaders(ish, ifh->NumberOfSections);

   //
   // Now enumerate the sections
   // - Section numbers start at 1
   // - Section name may or may not be NULL terminated
   // - Section name is limited to at most 8 characters
   //
   scnt = xcnt = 0;                         // Nothing yet
   for (i = 0; i < ifh->NumberOfSections; i++) {
      scnt++;                               // One more section

      //
      // Build section array entry
      //
      __try {
         sec[i].name = (char *)&(ish[i].Name);
         sec[i].number = i + 1;
         sec[i].start_addr = cr->load_addr + ish[i].VirtualAddress;
         sec[i].offset = ish[i].VirtualAddress;
         sec[i].size = ish[i].Misc.VirtualSize;
         sec[i].rawsize = ish[i].SizeOfRawData;
         sec[i].end_addr = sec[i].start_addr + sec[i].size - 1;
         sec[i].file_offset = ish[i].PointerToRawData;
         sec[i].flags = ish[i].Characteristics;
         sec[i].loc_addr = NULL;
         sec[i].symcnt = 0;
      }
      __except (EXCEPTION_EXECUTE_HANDLER) {
         // Handle access violations
         msg_log("\n**WARNING** ##### EXCEPTION 0x%X in EnumerateSections sec=%d#####\n",_exception_code(),i);
         scnt = 0;                          // Force 0 sections!
         return (0);
      }

      if (ish[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) {
         //
         // Executable section.
         // These are sections that contain executable code. As such, we
         // always gather code if requested to do so.
         //
         GatherCodeForSection(scnt);
         xcnt++;                            // One more executable section
      }
      else {
         //
         // Non-executable section.
         // These are sections that *MAY* contain code. There are times
         // (like in the java jvm.dll and jitc.dll, for example) where
         // sections not marked executable *DO* contain code. Don't know why
         // they do this but they do it.
         // If we come across a symbol in one of them we will save the
         // code later.
         //
      }
   }

   //
   // Done
   //
   dbghv(("< EnumerateSections: scnt=%d  xcnt=%d\n",scnt,xcnt));
   return (scnt);                           // Total number of sections
} // EnumerateSections()


//
// GatherCodeForSection()
// **********************
//
// Given a section number gather code (actually whatever data the
// section contains).
//
static void GatherCodeForSection(int secnum)
{
   void *sec_data;                          // Pointer to section data
   int s = secnum - 1;
   uint alloc_size, copy_size;


   dbghv(("> GatherCodeForSection(%d)\n",secnum));
   if (!G(gather_code)) {
      dbghv(("< GatherCodeForSection: not gathering code.\n"));
      return;                               // They don't want code
   }

   if (sec[s].loc_addr != NULL) {
      dbghv(("< GatherCodeForSection: have code already.\n"));
      return;                               // Already have code
   }

   alloc_size = max(sec[s].size, sec[s].rawsize);
   copy_size =  min(sec[s].size, sec[s].rawsize);

   sec[s].loc_addr = malloc(alloc_size);
   dbghv(("- GatherCodeForSection: malloc(%d (0x%08X)) bytes for code at 0x%p (NULL is bad)\n",
          alloc_size, alloc_size, sec[s].loc_addr));

   if (sec[s].loc_addr == NULL) {
      G(gather_code) = 0;                   // Don't try anymore
      dbghv(("- GatherCodeForSection: ***** Code gathering has been turned off *****\n"));
   }
   else {
      __try {
         sec_data = (void *)PtrAdd(dh, sec[s].file_offset);
         dbghv(("- GatherCodeForSection: saving %d (0x%08X) bytes of code from 0x%p to 0x%p for section %d\n",
                copy_size, copy_size, sec_data, sec[s].loc_addr, s+1));
         memset(sec[s].loc_addr, 0, alloc_size);
         memcpy(sec[s].loc_addr, sec_data, copy_size);
      }
      __except (EXCEPTION_EXECUTE_HANDLER) {
         // Handle access violations
         msg_log("\n**WARNING** ##### EXCEPTION 0x%X in GatherCodeForSection secnum=%d #####\n",_exception_code(),secnum);
         return;
      }
   }

   dbghv(("< GatherCodeForSection: done\n"));
   return;
}


//
// FindDebugDirectory()
// ********************
//
static IMAGE_DEBUG_DIRECTORY *FindDebugDirectory(void)
{
   IMAGE_NT_HEADERS *nth;                   // NT headers
   IMAGE_OPTIONAL_HEADER *ioh;              // Image optional header
   IMAGE_DEBUG_DIRECTORY *idd;              // Image debug directory
   DWORD debug_dir_rva;                     // Debug directory RVA
   int   idd_delta;                         // Delta from start of container section
   int i;
   uint ioh_NumberOfRvaAndSizes;
   IMAGE_DATA_DIRECTORY *ioh_DataDirectory;

   //
   // Find Export Directory.
   // It is usually within some section and we need to find the offset
   // within the containing section as well.
   //
   dbghv(("> FindDebugDirectory\n"));
   nth = (IMAGE_NT_HEADERS *)PtrAdd(dh, dh->e_lfanew);  // NT Header
   ioh = &(nth->OptionalHeader);                        // Image optional header

   //
   // Data directory numbers are 0-origin so we must have at least
   // one greater than the index for the debug directory.
   //
   ioh_NumberOfRvaAndSizes = GetIohNumberOfRvaAndSizes(ioh);
   if (ioh_NumberOfRvaAndSizes < (IMAGE_DIRECTORY_ENTRY_DEBUG + 1)) {
      dbghv(("< FindDebugDirectory: debug data directory not present\n"));
      return (NULL);
   }

   //
   // The debug data directory entry's RVA must be non-zero.
   // Zero means there is no debug directory.
   // Non-zero gives the offset of the Debug Directory relative to the
   // beginning of the .rdata section.
   //
   ioh_DataDirectory = GetIohDataDirectory(ioh);
   debug_dir_rva = ioh_DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
   if (debug_dir_rva == 0) {
      dbghv(("< FindDebugDirectory: debug_dir_rva == 0. Debug data directory not present.\n"));
      return (NULL);
   }

   //
   // Now find the Debug Directory.
   // It is usually within some section and we need to find the offset
   // within the containing section as well.
   //
   i = FindSectionForOffset((uint)debug_dir_rva);
   if (i == 0) {
      dbghv(("< FindDebugDirectory: Can't find section containing DEBUG DIRECTORY.\n"));
      return (NULL);
   }

   idd_delta = sec[i-1].offset - sec[i-1].file_offset;   // RVA - PtrToRawData
   idd = (IMAGE_DEBUG_DIRECTORY *)PtrAdd(dh, (debug_dir_rva - idd_delta));

   dbghv(("< FindDebugDirectory: idd=0x%p\n",idd));
   return (idd);
}


//
// FindSectionForAddress()
// ***********************
//
// Returns a section number or 0 if address isn't in any section.
//
int FindSectionForAddress(uint64 addr)
{
   int i;

   if (addr == 0)
      return (0);                           // Address can't be zero

   for (i = 0; i < scnt; i++) {
      if (addr >= sec[i].start_addr && addr <= sec[i].end_addr)
         return (i+1);
   }
   return (0);
}


//
// FindSectionForOffset()
// **********************
//
// Returns a section number or 0 if address isn't in any section.
//
int FindSectionForOffset(uint offset)
{
   int i;
   DWORD sec_end;

   for (i = 0; i < scnt; i++) {
      sec_end = sec[i].offset + sec[i].size;
      if (offset >= sec[i].offset && offset <= sec_end)
         return (i+1);
   }
   return (0);
}


//
// SectionIsExecutable()
// *********************
//
// Returns TRUE if section number is for an executable section
// and FALSE otherwise.
//
bool_t SectionIsExecutable(int num)
{
   if (num <= 0  ||  num > scnt)
      return (FALSE);
   else if (sec[num-1].flags & IMAGE_SCN_MEM_EXECUTE)
      return (TRUE);
   else
      return (FALSE);
}


//
// TsToDate()
// **********
//
// Returns the same thing ctime() returns!
//
char *TsToDate(uint ts)
{
   time_t tt = (time_t)ts;
   return (ctime(&tt));
}


char UndecoratedName[1024];                 // Global and hardcoded!
//
// DemangleName()
// **************
//
// Attempts to demangle (or undecorate) a symbol name.
// Returns pointer to undecorated name (if it was decorated)
// or to the original name (if it wasn't decorated) or if
// there was an error.
// UnDecorateSymbolName() doesn't do a real good job of removing
// calling convention decoration, nor of removing the leading
// underscore/dot added by the compiler/linker.
//
char *DemangleName(char *name)
{
   DWORD udlen;

   if (name[0] == '?') {
      if (G(demangle_complete)) {
         udlen = UnDecorateSymbolName(name, UndecoratedName,
                                      sizeof(UndecoratedName),
                                      (UNDNAME_COMPLETE | UNDNAME_32_BIT_DECODE));
      }
      else {
         udlen = UnDecorateSymbolName(name, UndecoratedName,
                                      sizeof(UndecoratedName),
                                      (UNDNAME_NAME_ONLY | UNDNAME_32_BIT_DECODE));
      }

      if (udlen != 0) {
         if (strcmp(UndecoratedName,"`string'") == 0) {
            dbghv(("- DemangleName: UnDecorateSymbolName() failed. Returned %s\n",UndecoratedName));
         }
         else {
            dbghv(("- DemangleName: undecorated=%s\n",UndecoratedName));
            return (UndecoratedName);          // Undecorated name
         }
      }
      else {
         dbghv(("- DemangleName: UnDecorateSymbolName() failed. rc=%d\n",GetLastError()));
      }
   }

   return (name);                           // Not decorated or error
}


//
// GetModuleType()
// ***************
//
// Determines the type of a given module.
// Returns the module type (or MODULE_TYPE_INVALID if it can't determine type).
//
static int GetModuleType(IMAGE_DOS_HEADER *dh)
{
   int rc;
   IMAGE_NT_HEADERS *nth;


   dbghv(("> GetModuleType: dh=0x%p\n",dh));

   //
   // DosSignature   PE/VXD/OS2 Signature   Module type
   //    "MZ"            "PE"                 PE
   //    "MZ"            "LE"                 Windows VXD or OS/2 LE
   //    "MZ"            "NE"                 OS/2 NE
   //
   if (dh->e_magic == IMAGE_OS2_SIGNATURE) {
      rc = MODULE_TYPE_NE;
      dbghv(("- GetModuleType: OS2 NE signature found\n"));
   }
   else if (dh->e_magic == IMAGE_OS2_SIGNATURE_LE) {
      rc = MODULE_TYPE_LE;
      dbghv(("- GetModuleType: OS2/Windows LE signature found\n"));
   }
   else if (dh->e_magic != IMAGE_DOS_SIGNATURE) {
      rc = MODULE_TYPE_INVALID;
      errmsg(("*E* GetModuleType: unknown module signature 0x04x\n",dh->e_magic));
   }
   else {
      //
      // If we make it here we know it's a valid DOS stub signature.
      // It can still be a old-style image (.COM) which we don't handle.
      //
      if (dh->e_lfarlc < 0x40 && dh->e_lfanew == 0) {
         rc = MODULE_TYPE_DOS;
         dbghv(("- GetModuleType: looks like an old-style DOS image\n"));
      }
      else {
         //
         // Not old-style DOS image. Check the PE signature to see
         // what this image is ...
         //
         nth = (IMAGE_NT_HEADERS *)PtrAdd(dh, dh->e_lfanew);
         if (nth->Signature == IMAGE_NT_SIGNATURE) {
            rc = MODULE_TYPE_PE;               // Looks like a PE executable
            dbghv(("- GetModuleType: PE Executable\n"));
         }
         else {
            rc = MODULE_TYPE_INVALID;
            errmsg(("*E* GetModuleType: module is not PE. Signature = 0x%08x\n",nth->Signature));
         }
      }
   }

   //
   // Done
   //
   dbghv(("< GetModuleType: rc=%d\n",rc));
   return (rc);
}


//
// GetCodePtrForSymbol()
// *********************
//
char *GetCodePtrForSymbol(uint symoffset, int secnum)
{
   char *cp;
   int s;

   s = secnum - 1;
   if (sec[s].symcnt == 1)
      GatherCodeForSection(secnum);         // Gather code on 1st hit

   if (sec[s].loc_addr == NULL)
      return (NULL);                        // No code

   cp = (char *)PtrAdd(sec[s].loc_addr, (symoffset - sec[s].offset));
   dbghv(("code_ptr = 0x%p  [%p + (0x%08x - %p)]\n",
          cp,(char *)sec[s].loc_addr,symoffset,sec[s].offset));

   return (cp);
}
