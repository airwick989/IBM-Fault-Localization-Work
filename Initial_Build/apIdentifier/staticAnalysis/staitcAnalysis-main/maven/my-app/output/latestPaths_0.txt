looking:latestPaths
synchronized (latestPaths) {
    toRemove = sources.put(peerId, src);
    if (toRemove != null) {
        LOG.info("Terminate replication source for " + toRemove.getPeerId());
        toRemove.terminate(terminateMessage);
        toRemove.getSourceMetrics().clear();
    }
    // Here we make a copy of all the remaining wal files and then delete them from the
    // replication queue storage after releasing the lock. It is not safe to just remove the old
    // map from walsById since later we may fail to delete them from the replication queue
    // storage, and when we retry next time, we can not know the wal files that need to be deleted
    // from the replication queue storage.
    walsById.get(peerId).forEach((k, v) -> wals.put(k, new TreeSet<>(v)));
}

synchronized (latestPaths) {
    toRemove = sources.put(peerId, src);
    if (toRemove != null) {
        LOG.info("Terminate replication source for " + toRemove.getPeerId());
        toRemove.terminate(terminateMessage);
        toRemove.getSourceMetrics().clear();
    }
    // Here we make a copy of all the remaining wal files and then delete them from the
    // replication queue storage after releasing the lock. It is not safe to just remove the old
    // map from walsById since later we may fail to delete them from the replication queue
    // storage, and when we retry next time, we can not know the wal files that need to be deleted
    // from the replication queue storage.
    walsById.get(peerId).forEach((k, v) -> wals.put(k, new TreeSet<>(v)));
}
possible Hot2
