looking:regionsInQueue
synchronized (regionsInQueue) {
    FlushRegionEntry existFqe = regionsInQueue.get(r);
    if (existFqe != null) {
        // if a delayed one exists and not reach the time to execute, just remove it
        if (existFqe.isDelay() && existFqe.whenToExpire > EnvironmentEdgeManager.currentTime()) {
            LOG.info("Remove the existing delayed flush entry for {}, " + "because we need to flush it immediately", r);
            this.regionsInQueue.remove(r);
            this.flushQueue.remove(existFqe);
            r.decrementFlushesQueuedCount();
        } else {
            tracker.notExecuted("Flush already requested on " + r);
            return false;
        }
    }
    // This entry has no delay so it will be added at the top of the flush
    // queue. It'll come out near immediately.
    FlushRegionEntry fqe = new FlushRegionEntry(r, families, tracker);
    this.regionsInQueue.put(r, fqe);
    this.flushQueue.add(fqe);
    r.incrementFlushesQueuedCount();
    return true;
}

synchronized (regionsInQueue) {
    FlushRegionEntry existFqe = regionsInQueue.get(r);
    if (existFqe != null) {
        // if a delayed one exists and not reach the time to execute, just remove it
        if (existFqe.isDelay() && existFqe.whenToExpire > EnvironmentEdgeManager.currentTime()) {
            LOG.info("Remove the existing delayed flush entry for {}, " + "because we need to flush it immediately", r);
            this.regionsInQueue.remove(r);
            this.flushQueue.remove(existFqe);
            r.decrementFlushesQueuedCount();
        } else {
            tracker.notExecuted("Flush already requested on " + r);
            return false;
        }
    }
    // This entry has no delay so it will be added at the top of the flush
    // queue. It'll come out near immediately.
    FlushRegionEntry fqe = new FlushRegionEntry(r, families, tracker);
    this.regionsInQueue.put(r, fqe);
    this.flushQueue.add(fqe);
    r.incrementFlushesQueuedCount();
    return true;
}
possible Hot2
