looking:this.blockSignal
synchronized (this.blockSignal) {
    boolean blocked = false;
    long startTime = 0;
    boolean interrupted = false;
    try {
        flushType = isAboveHighWaterMark();
        while (flushType != FlushType.NORMAL && !server.isStopped()) {
            if (!blocked) {
                startTime = EnvironmentEdgeManager.currentTime();
                if (!server.getRegionServerAccounting().isOffheap()) {
                    logMsg("global memstore heapsize", server.getRegionServerAccounting().getGlobalMemStoreHeapSize(), server.getRegionServerAccounting().getGlobalMemStoreLimit());
                } else {
                    switch(flushType) {
                        case ABOVE_OFFHEAP_HIGHER_MARK:
                            logMsg("the global offheap memstore datasize", server.getRegionServerAccounting().getGlobalMemStoreOffHeapSize(), server.getRegionServerAccounting().getGlobalMemStoreLimit());
                            break;
                        case ABOVE_ONHEAP_HIGHER_MARK:
                            logMsg("global memstore heapsize", server.getRegionServerAccounting().getGlobalMemStoreHeapSize(), server.getRegionServerAccounting().getGlobalOnHeapMemStoreLimit());
                            break;
                        default:
                            break;
                    }
                }
            }
            blocked = true;
            {
                if (wakeupPending.compareAndSet(false, true)) {
                    flushQueue.add(WAKEUPFLUSH_INSTANCE);
                }
            }
            try {
                // we should be able to wait forever, but we've seen a bug where
                // we miss a notify, so put a 5 second bound on it at least.
                blockSignal.wait(5 * 1000);
            } catch (InterruptedException ie) {
                LOG.warn("Interrupted while waiting");
                interrupted = true;
            }
            long nowMs = EnvironmentEdgeManager.currentTime();
            if (nowMs >= nextLogTimeMs) {
                LOG.warn("Memstore is above high water mark and block {} ms", nowMs - start);
                nextLogTimeMs = nowMs + 1000;
            }
            flushType = isAboveHighWaterMark();
        }
    } finally {
        if (interrupted) {
            Thread.currentThread().interrupt();
        }
    }
    if (blocked) {
        final long totalTime = EnvironmentEdgeManager.currentTime() - startTime;
        if (totalTime > 0) {
            this.updatesBlockedMsHighWater.add(totalTime);
        }
        LOG.info("Unblocking updates for server " + server.toString());
    }
}

synchronized (this.blockSignal) {
    boolean blocked = false;
    long startTime = 0;
    boolean interrupted = false;
    try {
        flushType = isAboveHighWaterMark();
        while (flushType != FlushType.NORMAL && !server.isStopped()) {
            if (!blocked) {
                startTime = EnvironmentEdgeManager.currentTime();
                if (!server.getRegionServerAccounting().isOffheap()) {
                    logMsg("global memstore heapsize", server.getRegionServerAccounting().getGlobalMemStoreHeapSize(), server.getRegionServerAccounting().getGlobalMemStoreLimit());
                } else {
                    switch(flushType) {
                        case ABOVE_OFFHEAP_HIGHER_MARK:
                            logMsg("the global offheap memstore datasize", server.getRegionServerAccounting().getGlobalMemStoreOffHeapSize(), server.getRegionServerAccounting().getGlobalMemStoreLimit());
                            break;
                        case ABOVE_ONHEAP_HIGHER_MARK:
                            logMsg("global memstore heapsize", server.getRegionServerAccounting().getGlobalMemStoreHeapSize(), server.getRegionServerAccounting().getGlobalOnHeapMemStoreLimit());
                            break;
                        default:
                            break;
                    }
                }
            }
            blocked = true;
            wakeupFlushThread();
            try {
                // we should be able to wait forever, but we've seen a bug where
                // we miss a notify, so put a 5 second bound on it at least.
                blockSignal.wait(5 * 1000);
            } catch (InterruptedException ie) {
                LOG.warn("Interrupted while waiting");
                interrupted = true;
            }
            long nowMs = EnvironmentEdgeManager.currentTime();
            if (nowMs >= nextLogTimeMs) {
                LOG.warn("Memstore is above high water mark and block {} ms", nowMs - start);
                nextLogTimeMs = nowMs + 1000;
            }
            flushType = isAboveHighWaterMark();
        }
    } finally {
        if (interrupted) {
            Thread.currentThread().interrupt();
        }
    }
    if (blocked) {
        final long totalTime = EnvironmentEdgeManager.currentTime() - startTime;
        if (totalTime > 0) {
            this.updatesBlockedMsHighWater.add(totalTime);
        }
        LOG.info("Unblocking updates for server " + server.toString());
    }
}
possible Hot1
possible type Hot3_2
1
