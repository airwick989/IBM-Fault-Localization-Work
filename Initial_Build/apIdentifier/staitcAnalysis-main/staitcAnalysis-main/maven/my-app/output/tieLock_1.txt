looking:tieLock
SequenceIdAccounting	startCacheFlush
-----------------------
synchronized (tieLock) {
    Map<ImmutableByteArray, Long> m = this.lowestUnflushedSequenceIds.get(encodedRegionName);
    if (m != null) {
        // NOTE: Removal from this.lowestUnflushedSequenceIds must be done in controlled
        // circumstance because another concurrent thread now may add sequenceids for this family
        // (see above in getOrCreateLowestSequenceId). Make sure you are ok with this. Usually it
        // is fine because updates are blocked when this method is called. Make sure!!!
        for (Map.Entry<byte[], Long> entry : familyToSeq.entrySet()) {
            ImmutableByteArray familyNameWrapper = ImmutableByteArray.wrap((byte[]) entry.getKey());
            Long seqId = null;
            if (entry.getValue() == HConstants.NO_SEQNUM) {
                seqId = m.remove(familyNameWrapper);
            } else {
                seqId = m.replace(familyNameWrapper, entry.getValue());
            }
            if (seqId != null) {
                if (oldSequenceIds == null) {
                    oldSequenceIds = new HashMap<>();
                }
                oldSequenceIds.put(familyNameWrapper, seqId);
            }
        }
        if (oldSequenceIds != null && !oldSequenceIds.isEmpty()) {
            if (this.flushingSequenceIds.put(encodedRegionName, oldSequenceIds) != null) {
                LOG.warn("Flushing Map not cleaned up for " + Bytes.toString(encodedRegionName) + ", sequenceid=" + oldSequenceIds);
            }
        }
        if (m.isEmpty()) {
            // Remove it otherwise it will be in oldestUnflushedStoreSequenceIds for ever
            // even if the region is already moved to other server.
            // Do not worry about data racing, we held write lock of region when calling
            // startCacheFlush, so no one can add value to the map we removed.
            this.lowestUnflushedSequenceIds.remove(encodedRegionName);
        } else {
            // Flushing a subset of the region families. Return the sequence id of the oldest entry.
            lowestUnflushedInRegion = Collections.min(m.values());
        }
    }
}
-----------------------
synchronized (tieLock) {
    Map<ImmutableByteArray, Long> m = this.lowestUnflushedSequenceIds.get(encodedRegionName);
    if (m != null) {
        // NOTE: Removal from this.lowestUnflushedSequenceIds must be done in controlled
        // circumstance because another concurrent thread now may add sequenceids for this family
        // (see above in getOrCreateLowestSequenceId). Make sure you are ok with this. Usually it
        // is fine because updates are blocked when this method is called. Make sure!!!
        for (Map.Entry<byte[], Long> entry : familyToSeq.entrySet()) {
            ImmutableByteArray familyNameWrapper = ImmutableByteArray.wrap((byte[]) entry.getKey());
            Long seqId = null;
            if (entry.getValue() == HConstants.NO_SEQNUM) {
                seqId = m.remove(familyNameWrapper);
            } else {
                seqId = m.replace(familyNameWrapper, entry.getValue());
            }
            if (seqId != null) {
                if (oldSequenceIds == null) {
                    oldSequenceIds = new HashMap<>();
                }
                oldSequenceIds.put(familyNameWrapper, seqId);
            }
        }
        if (oldSequenceIds != null && !oldSequenceIds.isEmpty()) {
            if (this.flushingSequenceIds.put(encodedRegionName, oldSequenceIds) != null) {
                LOG.warn("Flushing Map not cleaned up for " + Bytes.toString(encodedRegionName) + ", sequenceid=" + oldSequenceIds);
            }
        }
        if (m.isEmpty()) {
            // Remove it otherwise it will be in oldestUnflushedStoreSequenceIds for ever
            // even if the region is already moved to other server.
            // Do not worry about data racing, we held write lock of region when calling
            // startCacheFlush, so no one can add value to the map we removed.
            this.lowestUnflushedSequenceIds.remove(encodedRegionName);
        } else {
            // Flushing a subset of the region families. Return the sequence id of the oldest entry.
            lowestUnflushedInRegion = Collections.min(m.values());
        }
    }
}-----------------------
possible Hot2
possible type Hot3_2
1
