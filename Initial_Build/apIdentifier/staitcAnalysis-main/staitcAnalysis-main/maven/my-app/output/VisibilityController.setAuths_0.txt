looking:VisibilityController.setAuths
VisibilityController	setAuths
-----------------------
@Override
public synchronized void setAuths(RpcController controller, SetAuthsRequest request, RpcCallback<VisibilityLabelsResponse> done) {
    VisibilityLabelsResponse.Builder response = VisibilityLabelsResponse.newBuilder();
    List<ByteString> auths = request.getAuthList();
    if (!initialized) {
        setExceptionResults(auths.size(), new VisibilityControllerNotReadyException("VisibilityController not yet initialized!"), response);
    } else {
        byte[] user = request.getUser().toByteArray();
        List<byte[]> labelAuths = new ArrayList<>(auths.size());
        try {
            if (authorizationEnabled) {
                checkCallingUserAuth();
            }
            for (ByteString authBS : auths) {
                labelAuths.add(authBS.toByteArray());
            }
            OperationStatus[] opStatus = this.visibilityLabelService.setAuths(user, labelAuths);
            logResult(true, "setAuths", "Setting authorization for labels allowed", user, labelAuths, null);
            RegionActionResult successResult = RegionActionResult.newBuilder().build();
            for (OperationStatus status : opStatus) {
                if (status.getOperationStatusCode() == SUCCESS) {
                    response.addResult(successResult);
                } else {
                    RegionActionResult.Builder failureResultBuilder = RegionActionResult.newBuilder();
                    failureResultBuilder.setException(buildException(new DoNotRetryIOException(status.getExceptionMsg())));
                    response.addResult(failureResultBuilder.build());
                }
            }
        } catch (AccessDeniedException e) {
            logResult(false, "setAuths", e.getMessage(), user, labelAuths, null);
            LOG.error("User is not having required permissions to set authorization", e);
            setExceptionResults(auths.size(), e, response);
        } catch (IOException e) {
            LOG.error(e.toString(), e);
            setExceptionResults(auths.size(), e, response);
        }
    }
    done.run(response.build());
}
-----------------------
@Override
public synchronized void setAuths(RpcController controller, SetAuthsRequest request, RpcCallback<VisibilityLabelsResponse> done) {
    VisibilityLabelsResponse.Builder response = VisibilityLabelsResponse.newBuilder();
    List<ByteString> auths = request.getAuthList();
    if (!initialized) {
        setExceptionResults(auths.size(), new VisibilityControllerNotReadyException("VisibilityController not yet initialized!"), response);
    } else {
        byte[] user = request.getUser().toByteArray();
        List<byte[]> labelAuths = new ArrayList<>(auths.size());
        try {
            if (authorizationEnabled) {
                checkCallingUserAuth();
                {
                    if (!authorizationEnabled) {
                        // Redundant, but just in case
                        return;
                    }
                    if (!accessControllerAvailable) {
                        User user = VisibilityUtils.getActiveUser();
                        if (user == null) {
                            throw new IOException("Unable to retrieve calling user");
                        }
                        if (!(this.visibilityLabelService.havingSystemAuth(user))) {
                            throw new AccessDeniedException("User '" + user.getShortName() + "' is not authorized to perform this action.");
                        }
                    }
                }
            }
            for (ByteString authBS : auths) {
                labelAuths.add(authBS.toByteArray());
            }
            OperationStatus[] opStatus = this.visibilityLabelService.setAuths(user, labelAuths);
            logResult(true, "setAuths", "Setting authorization for labels allowed", user, labelAuths, null);
            RegionActionResult successResult = RegionActionResult.newBuilder().build();
            for (OperationStatus status : opStatus) {
                if (status.getOperationStatusCode() == SUCCESS) {
                    response.addResult(successResult);
                } else {
                    RegionActionResult.Builder failureResultBuilder = RegionActionResult.newBuilder();
                    failureResultBuilder.setException(buildException(new DoNotRetryIOException(status.getExceptionMsg())));
                    response.addResult(failureResultBuilder.build());
                }
            }
            {
                if (AUDITLOG.isTraceEnabled()) {
                    // This is more duplicated code!
                    List<String> labelAuthsStr = new ArrayList<>();
                    if (labelAuths != null) {
                        int labelAuthsSize = labelAuths.size();
                        labelAuthsStr = new ArrayList<>(labelAuthsSize);
                        for (int i = 0; i < labelAuthsSize; i++) {
                            labelAuthsStr.add(Bytes.toString(labelAuths.get(i)));
                        }
                    }
                    User requestingUser = null;
                    try {
                        requestingUser = VisibilityUtils.getActiveUser();
                    } catch (IOException e) {
                        LOG.warn("Failed to get active system user.");
                        LOG.debug("Details on failure to get active system user.", e);
                    }
                    AUDITLOG.trace("Access " + (isAllowed ? "allowed" : "denied") + " for user " + (requestingUser != null ? requestingUser.getShortName() : "UNKNOWN") + "; reason: " + reason + "; remote address: " + RpcServer.getRemoteAddress().map(InetAddress::toString).orElse("") + "; request: " + request + "; user: " + (user != null ? Bytes.toShort(user) : "null") + "; labels: " + labelAuthsStr + "; regex: " + regex);
                }
            }
        } catch (AccessDeniedException e) {
            logResult(false, "setAuths", e.getMessage(), user, labelAuths, null);
            LOG.error("User is not having required permissions to set authorization", e);
            setExceptionResults(auths.size(), e, response);
        } catch (IOException e) {
            LOG.error(e.toString(), e);
            setExceptionResults(auths.size(), e, response);
        }
    }
    done.run(response.build());
}-----------------------
possible Hot1
possible type Hot3_2
1
