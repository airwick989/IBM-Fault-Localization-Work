looking:HbckChore.chore
HbckChore	chore
-----------------------
@Override
protected synchronized void chore() {
    if (isDisabled() || isRunning()) {
        LOG.warn("hbckChore is either disabled or is already running. Can't run the chore");
        return;
    }
    running = true;
    final HbckReport report = new HbckReport();
    report.setCheckingStartTimestamp(Instant.ofEpochMilli(EnvironmentEdgeManager.currentTime()));
    try {
        loadRegionsFromInMemoryState(report);
        loadRegionsFromRSReport(report);
        try {
            loadRegionsFromFS(scanForMergedParentRegions(), report);
        } catch (IOException e) {
            LOG.warn("Failed to load the regions from filesystem", e);
        }
    } catch (Throwable t) {
        LOG.warn("Unexpected", t);
    }
    report.setCheckingEndTimestamp(Instant.ofEpochMilli(EnvironmentEdgeManager.currentTime()));
    this.lastReport = report;
    running = false;
    updateAssignmentManagerMetrics(report);
}
-----------------------
@Override
protected synchronized void chore() {
    if (isDisabled() || isRunning()) {
        LOG.warn("hbckChore is either disabled or is already running. Can't run the chore");
        return;
    }
    running = true;
    final HbckReport report = new HbckReport();
    report.setCheckingStartTimestamp(Instant.ofEpochMilli(EnvironmentEdgeManager.currentTime()));
    try {
        loadRegionsFromInMemoryState(report);
        loadRegionsFromRSReport(report);
        try {
            loadRegionsFromFS(scanForMergedParentRegions(), report);
            {
                Path rootDir = master.getMasterFileSystem().getRootDir();
                FileSystem fs = master.getMasterFileSystem().getFileSystem();
                int numRegions = 0;
                List<Path> tableDirs = FSUtils.getTableDirs(fs, rootDir);
                for (Path tableDir : tableDirs) {
                    List<Path> regionDirs = FSUtils.getRegionDirs(fs, tableDir);
                    for (Path regionDir : regionDirs) {
                        String encodedRegionName = regionDir.getName();
                        if (encodedRegionName == null) {
                            LOG.warn("Failed get of encoded name from {}", regionDir);
                            continue;
                        }
                        HbckRegionInfo hri = report.getRegionInfoMap().get(encodedRegionName);
                        // If it is not in in-memory database and not a merged region,
                        // report it as an orphan region.
                        if (hri == null && !mergedParentRegions.contains(encodedRegionName)) {
                            report.getOrphanRegionsOnFS().put(encodedRegionName, regionDir);
                            continue;
                        }
                    }
                    numRegions += regionDirs.size();
                }
                LOG.info("Loaded {} tables {} regions from filesystem and found {} orphan regions", tableDirs.size(), numRegions, report.getOrphanRegionsOnFS().size());
            }
            {
                Path rootDir = master.getMasterFileSystem().getRootDir();
                FileSystem fs = master.getMasterFileSystem().getFileSystem();
                int numRegions = 0;
                List<Path> tableDirs = FSUtils.getTableDirs(fs, rootDir);
                for (Path tableDir : tableDirs) {
                    List<Path> regionDirs = FSUtils.getRegionDirs(fs, tableDir);
                    for (Path regionDir : regionDirs) {
                        String encodedRegionName = regionDir.getName();
                        if (encodedRegionName == null) {
                            LOG.warn("Failed get of encoded name from {}", regionDir);
                            continue;
                        }
                        HbckRegionInfo hri = report.getRegionInfoMap().get(encodedRegionName);
                        // If it is not in in-memory database and not a merged region,
                        // report it as an orphan region.
                        if (hri == null && !mergedParentRegions.contains(encodedRegionName)) {
                            report.getOrphanRegionsOnFS().put(encodedRegionName, regionDir);
                            continue;
                        }
                    }
                    numRegions += regionDirs.size();
                }
                LOG.info("Loaded {} tables {} regions from filesystem and found {} orphan regions", tableDirs.size(), numRegions, report.getOrphanRegionsOnFS().size());
            }
        } catch (IOException e) {
            LOG.warn("Failed to load the regions from filesystem", e);
        }
        {
            List<RegionState> regionStates = master.getAssignmentManager().getRegionStates().getRegionStates();
            for (RegionState regionState : regionStates) {
                RegionInfo regionInfo = regionState.getRegion();
                if (master.getTableStateManager().isTableState(regionInfo.getTable(), TableState.State.DISABLED)) {
                    report.getDisabledTableRegions().add(regionInfo.getRegionNameAsString());
                }
                // Check both state and regioninfo for split status, see HBASE-26383
                if (regionState.isSplit() || regionInfo.isSplit()) {
                    report.getSplitParentRegions().add(regionInfo.getRegionNameAsString());
                }
                HbckRegionInfo.MetaEntry metaEntry = new HbckRegionInfo.MetaEntry(regionInfo, regionState.getServerName(), regionState.getStamp());
                report.getRegionInfoMap().put(regionInfo.getEncodedName(), new HbckRegionInfo(metaEntry));
            }
            LOG.info("Loaded {} regions ({} disabled, {} split parents) from in-memory state", regionStates.size(), report.getDisabledTableRegions().size(), report.getSplitParentRegions().size());
            if (LOG.isDebugEnabled()) {
                Map<RegionState.State, Integer> stateCountMap = new HashMap<>();
                for (RegionState regionState : regionStates) {
                    stateCountMap.compute(regionState.getState(), (k, v) -> (v == null) ? 1 : v + 1);
                }
                StringBuffer sb = new StringBuffer();
                sb.append("Regions by state: ");
                stateCountMap.entrySet().forEach(e -> {
                    sb.append(e.getKey());
                    sb.append('=');
                    sb.append(e.getValue());
                    sb.append(' ');
                });
                LOG.debug(sb.toString());
            }
            if (LOG.isTraceEnabled()) {
                for (RegionState regionState : regionStates) {
                    LOG.trace("{}: {}, serverName={}", regionState.getRegion(), regionState.getState(), regionState.getServerName());
                }
            }
        }
        {
            List<RegionState> regionStates = master.getAssignmentManager().getRegionStates().getRegionStates();
            for (RegionState regionState : regionStates) {
                RegionInfo regionInfo = regionState.getRegion();
                if (master.getTableStateManager().isTableState(regionInfo.getTable(), TableState.State.DISABLED)) {
                    report.getDisabledTableRegions().add(regionInfo.getRegionNameAsString());
                }
                // Check both state and regioninfo for split status, see HBASE-26383
                if (regionState.isSplit() || regionInfo.isSplit()) {
                    report.getSplitParentRegions().add(regionInfo.getRegionNameAsString());
                }
                HbckRegionInfo.MetaEntry metaEntry = new HbckRegionInfo.MetaEntry(regionInfo, regionState.getServerName(), regionState.getStamp());
                report.getRegionInfoMap().put(regionInfo.getEncodedName(), new HbckRegionInfo(metaEntry));
            }
            LOG.info("Loaded {} regions ({} disabled, {} split parents) from in-memory state", regionStates.size(), report.getDisabledTableRegions().size(), report.getSplitParentRegions().size());
            if (LOG.isDebugEnabled()) {
                Map<RegionState.State, Integer> stateCountMap = new HashMap<>();
                for (RegionState regionState : regionStates) {
                    stateCountMap.compute(regionState.getState(), (k, v) -> (v == null) ? 1 : v + 1);
                }
                StringBuffer sb = new StringBuffer();
                sb.append("Regions by state: ");
                stateCountMap.entrySet().forEach(e -> {
                    sb.append(e.getKey());
                    sb.append('=');
                    sb.append(e.getValue());
                    sb.append(' ');
                });
                LOG.debug(sb.toString());
            }
            if (LOG.isTraceEnabled()) {
                for (RegionState regionState : regionStates) {
                    LOG.trace("{}: {}, serverName={}", regionState.getRegion(), regionState.getState(), regionState.getServerName());
                }
            }
        }
        {
            int numRegions = 0;
            Map<ServerName, Set<byte[]>> rsReports = master.getAssignmentManager().getRSReports();
            for (Map.Entry<ServerName, Set<byte[]>> entry : rsReports.entrySet()) {
                ServerName serverName = entry.getKey();
                for (byte[] regionName : entry.getValue()) {
                    String encodedRegionName = RegionInfo.encodeRegionName(regionName);
                    HbckRegionInfo hri = report.getRegionInfoMap().get(encodedRegionName);
                    if (hri == null) {
                        report.getOrphanRegionsOnRS().put(RegionInfo.getRegionNameAsString(regionName), serverName);
                        continue;
                    }
                    hri.addServer(hri.getMetaEntry().getRegionInfo(), serverName);
                }
                numRegions += entry.getValue().size();
            }
            LOG.info("Loaded {} regions from {} regionservers' reports and found {} orphan regions", numRegions, rsReports.size(), report.getOrphanRegionsOnRS().size());
            for (Map.Entry<String, HbckRegionInfo> entry : report.getRegionInfoMap().entrySet()) {
                HbckRegionInfo hri = entry.getValue();
                ServerName locationInMeta = hri.getMetaEntry().getRegionServer();
                if (locationInMeta == null) {
                    continue;
                }
                if (hri.getDeployedOn().size() == 0) {
                    // skip the offline region which belong to disabled table.
                    if (report.getDisabledTableRegions().contains(hri.getRegionNameAsString())) {
                        continue;
                    }
                    // skip the split parent regions
                    if (report.getSplitParentRegions().contains(hri.getRegionNameAsString())) {
                        continue;
                    }
                    // Master thought this region opened, but no regionserver reported it.
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, new LinkedList<>()));
                } else if (hri.getDeployedOn().size() > 1) {
                    // More than one regionserver reported opened this region
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, hri.getDeployedOn()));
                } else if (!hri.getDeployedOn().get(0).equals(locationInMeta)) {
                    // Master thought this region opened on Server1, but regionserver reported Server2
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, hri.getDeployedOn()));
                }
            }
        }
        {
            List<RegionState> regionStates = master.getAssignmentManager().getRegionStates().getRegionStates();
            for (RegionState regionState : regionStates) {
                RegionInfo regionInfo = regionState.getRegion();
                if (master.getTableStateManager().isTableState(regionInfo.getTable(), TableState.State.DISABLED)) {
                    report.getDisabledTableRegions().add(regionInfo.getRegionNameAsString());
                }
                // Check both state and regioninfo for split status, see HBASE-26383
                if (regionState.isSplit() || regionInfo.isSplit()) {
                    report.getSplitParentRegions().add(regionInfo.getRegionNameAsString());
                }
                HbckRegionInfo.MetaEntry metaEntry = new HbckRegionInfo.MetaEntry(regionInfo, regionState.getServerName(), regionState.getStamp());
                report.getRegionInfoMap().put(regionInfo.getEncodedName(), new HbckRegionInfo(metaEntry));
            }
            LOG.info("Loaded {} regions ({} disabled, {} split parents) from in-memory state", regionStates.size(), report.getDisabledTableRegions().size(), report.getSplitParentRegions().size());
            if (LOG.isDebugEnabled()) {
                Map<RegionState.State, Integer> stateCountMap = new HashMap<>();
                for (RegionState regionState : regionStates) {
                    stateCountMap.compute(regionState.getState(), (k, v) -> (v == null) ? 1 : v + 1);
                }
                StringBuffer sb = new StringBuffer();
                sb.append("Regions by state: ");
                stateCountMap.entrySet().forEach(e -> {
                    sb.append(e.getKey());
                    sb.append('=');
                    sb.append(e.getValue());
                    sb.append(' ');
                });
                LOG.debug(sb.toString());
            }
            if (LOG.isTraceEnabled()) {
                for (RegionState regionState : regionStates) {
                    LOG.trace("{}: {}, serverName={}", regionState.getRegion(), regionState.getState(), regionState.getServerName());
                }
            }
        }
        {
            int numRegions = 0;
            Map<ServerName, Set<byte[]>> rsReports = master.getAssignmentManager().getRSReports();
            for (Map.Entry<ServerName, Set<byte[]>> entry : rsReports.entrySet()) {
                ServerName serverName = entry.getKey();
                for (byte[] regionName : entry.getValue()) {
                    String encodedRegionName = RegionInfo.encodeRegionName(regionName);
                    HbckRegionInfo hri = report.getRegionInfoMap().get(encodedRegionName);
                    if (hri == null) {
                        report.getOrphanRegionsOnRS().put(RegionInfo.getRegionNameAsString(regionName), serverName);
                        continue;
                    }
                    hri.addServer(hri.getMetaEntry().getRegionInfo(), serverName);
                }
                numRegions += entry.getValue().size();
            }
            LOG.info("Loaded {} regions from {} regionservers' reports and found {} orphan regions", numRegions, rsReports.size(), report.getOrphanRegionsOnRS().size());
            for (Map.Entry<String, HbckRegionInfo> entry : report.getRegionInfoMap().entrySet()) {
                HbckRegionInfo hri = entry.getValue();
                ServerName locationInMeta = hri.getMetaEntry().getRegionServer();
                if (locationInMeta == null) {
                    continue;
                }
                if (hri.getDeployedOn().size() == 0) {
                    // skip the offline region which belong to disabled table.
                    if (report.getDisabledTableRegions().contains(hri.getRegionNameAsString())) {
                        continue;
                    }
                    // skip the split parent regions
                    if (report.getSplitParentRegions().contains(hri.getRegionNameAsString())) {
                        continue;
                    }
                    // Master thought this region opened, but no regionserver reported it.
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, new LinkedList<>()));
                } else if (hri.getDeployedOn().size() > 1) {
                    // More than one regionserver reported opened this region
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, hri.getDeployedOn()));
                } else if (!hri.getDeployedOn().get(0).equals(locationInMeta)) {
                    // Master thought this region opened on Server1, but regionserver reported Server2
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, hri.getDeployedOn()));
                }
            }
        }
        {
            List<RegionState> regionStates = master.getAssignmentManager().getRegionStates().getRegionStates();
            for (RegionState regionState : regionStates) {
                RegionInfo regionInfo = regionState.getRegion();
                if (master.getTableStateManager().isTableState(regionInfo.getTable(), TableState.State.DISABLED)) {
                    report.getDisabledTableRegions().add(regionInfo.getRegionNameAsString());
                }
                // Check both state and regioninfo for split status, see HBASE-26383
                if (regionState.isSplit() || regionInfo.isSplit()) {
                    report.getSplitParentRegions().add(regionInfo.getRegionNameAsString());
                }
                HbckRegionInfo.MetaEntry metaEntry = new HbckRegionInfo.MetaEntry(regionInfo, regionState.getServerName(), regionState.getStamp());
                report.getRegionInfoMap().put(regionInfo.getEncodedName(), new HbckRegionInfo(metaEntry));
            }
            LOG.info("Loaded {} regions ({} disabled, {} split parents) from in-memory state", regionStates.size(), report.getDisabledTableRegions().size(), report.getSplitParentRegions().size());
            if (LOG.isDebugEnabled()) {
                Map<RegionState.State, Integer> stateCountMap = new HashMap<>();
                for (RegionState regionState : regionStates) {
                    stateCountMap.compute(regionState.getState(), (k, v) -> (v == null) ? 1 : v + 1);
                }
                StringBuffer sb = new StringBuffer();
                sb.append("Regions by state: ");
                stateCountMap.entrySet().forEach(e -> {
                    sb.append(e.getKey());
                    sb.append('=');
                    sb.append(e.getValue());
                    sb.append(' ');
                });
                LOG.debug(sb.toString());
            }
            if (LOG.isTraceEnabled()) {
                for (RegionState regionState : regionStates) {
                    LOG.trace("{}: {}, serverName={}", regionState.getRegion(), regionState.getState(), regionState.getServerName());
                }
            }
        }
        {
            int numRegions = 0;
            Map<ServerName, Set<byte[]>> rsReports = master.getAssignmentManager().getRSReports();
            for (Map.Entry<ServerName, Set<byte[]>> entry : rsReports.entrySet()) {
                ServerName serverName = entry.getKey();
                for (byte[] regionName : entry.getValue()) {
                    String encodedRegionName = RegionInfo.encodeRegionName(regionName);
                    HbckRegionInfo hri = report.getRegionInfoMap().get(encodedRegionName);
                    if (hri == null) {
                        report.getOrphanRegionsOnRS().put(RegionInfo.getRegionNameAsString(regionName), serverName);
                        continue;
                    }
                    hri.addServer(hri.getMetaEntry().getRegionInfo(), serverName);
                }
                numRegions += entry.getValue().size();
            }
            LOG.info("Loaded {} regions from {} regionservers' reports and found {} orphan regions", numRegions, rsReports.size(), report.getOrphanRegionsOnRS().size());
            for (Map.Entry<String, HbckRegionInfo> entry : report.getRegionInfoMap().entrySet()) {
                HbckRegionInfo hri = entry.getValue();
                ServerName locationInMeta = hri.getMetaEntry().getRegionServer();
                if (locationInMeta == null) {
                    continue;
                }
                if (hri.getDeployedOn().size() == 0) {
                    // skip the offline region which belong to disabled table.
                    if (report.getDisabledTableRegions().contains(hri.getRegionNameAsString())) {
                        continue;
                    }
                    // skip the split parent regions
                    if (report.getSplitParentRegions().contains(hri.getRegionNameAsString())) {
                        continue;
                    }
                    // Master thought this region opened, but no regionserver reported it.
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, new LinkedList<>()));
                } else if (hri.getDeployedOn().size() > 1) {
                    // More than one regionserver reported opened this region
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, hri.getDeployedOn()));
                } else if (!hri.getDeployedOn().get(0).equals(locationInMeta)) {
                    // Master thought this region opened on Server1, but regionserver reported Server2
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, hri.getDeployedOn()));
                }
            }
        }
    } catch (Throwable t) {
        LOG.warn("Unexpected", t);
    }
    report.setCheckingEndTimestamp(Instant.ofEpochMilli(EnvironmentEdgeManager.currentTime()));
    this.lastReport = report;
    running = false;
    updateAssignmentManagerMetrics(report);
    {
        master.getAssignmentManager().getAssignmentManagerMetrics().updateOrphanRegionsOnRs(report.getOrphanRegionsOnRS().size());
        master.getAssignmentManager().getAssignmentManagerMetrics().updateOrphanRegionsOnFs(report.getOrphanRegionsOnFS().size());
        master.getAssignmentManager().getAssignmentManagerMetrics().updateInconsistentRegions(report.getInconsistentRegions().size());
    }
}-----------------------
possible Hot1
possible type Hot3_2
2
