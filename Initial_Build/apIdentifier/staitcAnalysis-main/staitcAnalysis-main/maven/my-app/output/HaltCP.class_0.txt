looking:HaltCP.class
HaltCP	postExecuteProcedures
-----------------------
synchronized (HaltCP.class) {
    if (!HALT) {
        return;
    }
    UTIL1.getMiniHBaseCluster().getMaster().getProcedures().stream().filter(p -> p instanceof TransitPeerSyncReplicationStateProcedure).filter(p -> !p.isFinished()).map(p -> (TransitPeerSyncReplicationStateProcedure) p).findFirst().ifPresent(proc -> {
        // this is the next state of REFRESH_PEER_SYNC_REPLICATION_STATE_ON_RS_BEGIN_VALUE
        if (proc.getCurrentStateId() == REOPEN_ALL_REGIONS_IN_PEER_VALUE) {
            // tell the main thread to start a new region server
            ARRIVE.countDown();
            try {
                // wait for the region server to online
                RESUME.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            HALT = false;
        }
    });
}
-----------------------
synchronized (HaltCP.class) {
    if (!HALT) {
        return;
    }
    UTIL1.getMiniHBaseCluster().getMaster().getProcedures().stream().filter(p -> p instanceof TransitPeerSyncReplicationStateProcedure).filter(p -> !p.isFinished()).map(p -> (TransitPeerSyncReplicationStateProcedure) p).findFirst().ifPresent(proc -> {
        // this is the next state of REFRESH_PEER_SYNC_REPLICATION_STATE_ON_RS_BEGIN_VALUE
        if (proc.getCurrentStateId() == REOPEN_ALL_REGIONS_IN_PEER_VALUE) {
            // tell the main thread to start a new region server
            ARRIVE.countDown();
            try {
                // wait for the region server to online
                RESUME.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            HALT = false;
        }
    });
}-----------------------
possible Hot1
