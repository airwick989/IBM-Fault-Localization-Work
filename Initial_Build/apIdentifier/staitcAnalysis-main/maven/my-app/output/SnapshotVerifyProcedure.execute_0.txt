looking:SnapshotVerifyProcedure.execute
@Override
protected synchronized Procedure<MasterProcedureEnv>[] execute(MasterProcedureEnv env) throws ProcedureYieldException, ProcedureSuspendedException, InterruptedException {
    try {
        // if we've already known the snapshot is corrupted, then stop scheduling
        // the new procedures and the undispatched procedures
        if (!dispatched) {
            SnapshotProcedure parent = env.getMasterServices().getMasterProcedureExecutor().getProcedure(SnapshotProcedure.class, getParentProcId());
            if (parent != null && parent.isSnapshotCorrupted()) {
                return null;
            }
        }
        // acquire a worker
        if (!dispatched && targetServer == null) {
            targetServer = env.getMasterServices().getSnapshotManager().acquireSnapshotVerifyWorker(this);
        }
        // send remote request
        Procedure<MasterProcedureEnv>[] res = super.execute(env);
        // retry if necessary
        if (!dispatched) {
            // the mostly like thing is that a FailedRemoteDispatchException is thrown.
            // we need to retry on another remote server
            targetServer = null;
            throw new FailedRemoteDispatchException("Failed sent request");
        } else {
            // the request was successfully dispatched
            return res;
        }
    } catch (IOException e) {
        // there are some cases we need to retry:
        // 1. we can't get response from hdfs
        // 2. the remote server crashed
        if (retryCounter == null) {
            retryCounter = ProcedureUtil.createRetryCounter(env.getMasterConfiguration());
        }
        long backoff = retryCounter.getBackoffTimeAndIncrementAttempts();
        LOG.warn("Failed to get snapshot verify result , wait {} ms to retry", backoff, e);
        setTimeout(Math.toIntExact(backoff));
        setState(ProcedureProtos.ProcedureState.WAITING_TIMEOUT);
        skipPersistence();
        throw new ProcedureSuspendedException();
    }
}

@Override
protected synchronized Procedure<MasterProcedureEnv>[] execute(MasterProcedureEnv env) throws ProcedureYieldException, ProcedureSuspendedException, InterruptedException {
    try {
        // if we've already known the snapshot is corrupted, then stop scheduling
        // the new procedures and the undispatched procedures
        if (!dispatched) {
            SnapshotProcedure parent = env.getMasterServices().getMasterProcedureExecutor().getProcedure(SnapshotProcedure.class, getParentProcId());
            if (parent != null && parent.isSnapshotCorrupted()) {
                return null;
            }
        }
        // acquire a worker
        if (!dispatched && targetServer == null) {
            targetServer = env.getMasterServices().getSnapshotManager().acquireSnapshotVerifyWorker(this);
        }
        // send remote request
        Procedure<MasterProcedureEnv>[] res = super.execute(env);
        // retry if necessary
        if (!dispatched) {
            // the mostly like thing is that a FailedRemoteDispatchException is thrown.
            // we need to retry on another remote server
            targetServer = null;
            throw new FailedRemoteDispatchException("Failed sent request");
        } else {
            // the request was successfully dispatched
            return res;
        }
    } catch (IOException e) {
        // there are some cases we need to retry:
        // 1. we can't get response from hdfs
        // 2. the remote server crashed
        if (retryCounter == null) {
            retryCounter = ProcedureUtil.createRetryCounter(env.getMasterConfiguration());
        }
        long backoff = retryCounter.getBackoffTimeAndIncrementAttempts();
        LOG.warn("Failed to get snapshot verify result , wait {} ms to retry", backoff, e);
        setTimeout(Math.toIntExact(backoff));
        setState(ProcedureProtos.ProcedureState.WAITING_TIMEOUT);
        skipPersistence();
        throw new ProcedureSuspendedException();
    }
}
possible Hot1
