looking:HbckChore.chore
@Override
protected synchronized void chore() {
    if (isDisabled() || isRunning()) {
        LOG.warn("hbckChore is either disabled or is already running. Can't run the chore");
        return;
    }
    running = true;
    final HbckReport report = new HbckReport();
    report.setCheckingStartTimestamp(Instant.ofEpochMilli(EnvironmentEdgeManager.currentTime()));
    try {
        {
            int numRegions = 0;
            Map<ServerName, Set<byte[]>> rsReports = master.getAssignmentManager().getRSReports();
            for (Map.Entry<ServerName, Set<byte[]>> entry : rsReports.entrySet()) {
                ServerName serverName = entry.getKey();
                for (byte[] regionName : entry.getValue()) {
                    String encodedRegionName = RegionInfo.encodeRegionName(regionName);
                    HbckRegionInfo hri = report.getRegionInfoMap().get(encodedRegionName);
                    if (hri == null) {
                        report.getOrphanRegionsOnRS().put(RegionInfo.getRegionNameAsString(regionName), serverName);
                        continue;
                    }
                    hri.addServer(hri.getMetaEntry().getRegionInfo(), serverName);
                }
                numRegions += entry.getValue().size();
            }
            LOG.info("Loaded {} regions from {} regionservers' reports and found {} orphan regions", numRegions, rsReports.size(), report.getOrphanRegionsOnRS().size());
            for (Map.Entry<String, HbckRegionInfo> entry : report.getRegionInfoMap().entrySet()) {
                HbckRegionInfo hri = entry.getValue();
                ServerName locationInMeta = hri.getMetaEntry().getRegionServer();
                if (locationInMeta == null) {
                    continue;
                }
                if (hri.getDeployedOn().size() == 0) {
                    // skip the offline region which belong to disabled table.
                    if (report.getDisabledTableRegions().contains(hri.getRegionNameAsString())) {
                        continue;
                    }
                    // skip the split parent regions
                    if (report.getSplitParentRegions().contains(hri.getRegionNameAsString())) {
                        continue;
                    }
                    // Master thought this region opened, but no regionserver reported it.
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, new LinkedList<>()));
                } else if (hri.getDeployedOn().size() > 1) {
                    // More than one regionserver reported opened this region
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, hri.getDeployedOn()));
                } else if (!hri.getDeployedOn().get(0).equals(locationInMeta)) {
                    // Master thought this region opened on Server1, but regionserver reported Server2
                    report.getInconsistentRegions().put(hri.getRegionNameAsString(), new Pair<>(locationInMeta, hri.getDeployedOn()));
                }
            }
        }
        loadRegionsFromRSReport(report);
        try {
            {
                Path rootDir = master.getMasterFileSystem().getRootDir();
                FileSystem fs = master.getMasterFileSystem().getFileSystem();
                int numRegions = 0;
                List<Path> tableDirs = FSUtils.getTableDirs(fs, rootDir);
                for (Path tableDir : tableDirs) {
                    List<Path> regionDirs = FSUtils.getRegionDirs(fs, tableDir);
                    for (Path regionDir : regionDirs) {
                        String encodedRegionName = regionDir.getName();
                        if (encodedRegionName == null) {
                            LOG.warn("Failed get of encoded name from {}", regionDir);
                            continue;
                        }
                        HbckRegionInfo hri = report.getRegionInfoMap().get(encodedRegionName);
                        // If it is not in in-memory database and not a merged region,
                        // report it as an orphan region.
                        if (hri == null && !mergedParentRegions.contains(encodedRegionName)) {
                            report.getOrphanRegionsOnFS().put(encodedRegionName, regionDir);
                            continue;
                        }
                    }
                    numRegions += regionDirs.size();
                }
                LOG.info("Loaded {} tables {} regions from filesystem and found {} orphan regions", tableDirs.size(), numRegions, report.getOrphanRegionsOnFS().size());
            }
        } catch (IOException e) {
            LOG.warn("Failed to load the regions from filesystem", e);
        }
    } catch (Throwable t) {
        LOG.warn("Unexpected", t);
    }
    report.setCheckingEndTimestamp(Instant.ofEpochMilli(EnvironmentEdgeManager.currentTime()));
    this.lastReport = report;
    running = false;
    {
        master.getAssignmentManager().getAssignmentManagerMetrics().updateOrphanRegionsOnRs(report.getOrphanRegionsOnRS().size());
        master.getAssignmentManager().getAssignmentManagerMetrics().updateOrphanRegionsOnFs(report.getOrphanRegionsOnFS().size());
        master.getAssignmentManager().getAssignmentManagerMetrics().updateInconsistentRegions(report.getInconsistentRegions().size());
    }
}

@Override
protected synchronized void chore() {
    if (isDisabled() || isRunning()) {
        LOG.warn("hbckChore is either disabled or is already running. Can't run the chore");
        return;
    }
    running = true;
    final HbckReport report = new HbckReport();
    report.setCheckingStartTimestamp(Instant.ofEpochMilli(EnvironmentEdgeManager.currentTime()));
    try {
        loadRegionsFromInMemoryState(report);
        loadRegionsFromRSReport(report);
        try {
            loadRegionsFromFS(scanForMergedParentRegions(), report);
        } catch (IOException e) {
            LOG.warn("Failed to load the regions from filesystem", e);
        }
    } catch (Throwable t) {
        LOG.warn("Unexpected", t);
    }
    report.setCheckingEndTimestamp(Instant.ofEpochMilli(EnvironmentEdgeManager.currentTime()));
    this.lastReport = report;
    running = false;
    updateAssignmentManagerMetrics(report);
}
possible Hot1
possible type Hot3_2
2
