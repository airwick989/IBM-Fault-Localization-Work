looking:writestate
// the original seqIds.
synchronized (writestate) {
    try {
        if (flush.getFlushSequenceNumber() < lastReplayedOpenRegionSeqId) {
            LOG.warn(getRegionInfo().getEncodedName() + " : " + "Skipping replaying flush event :" + TextFormat.shortDebugString(flush) + " because its sequence id is smaller than this regions lastReplayedOpenRegionSeqId " + " of " + lastReplayedOpenRegionSeqId);
            return;
        }
        if (writestate.flushing) {
            PrepareFlushResult prepareFlushResult = this.prepareFlushResult;
            if (flush.getFlushSequenceNumber() == prepareFlushResult.flushOpSeqId) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker with seqId:" + flush.getFlushSequenceNumber() + " and a previous prepared snapshot was found");
                }
                // This is the regular case where we received commit flush after prepare flush
                // corresponding to the same seqId.
                replayFlushInStores(flush, prepareFlushResult, true);
                {
                    decrMemStoreSize(mss.getDataSize(), mss.getHeapSize(), mss.getOffHeapSize(), mss.getCellsCount());
                }
                this.prepareFlushResult = null;
                writestate.flushing = false;
            } else if (flush.getFlushSequenceNumber() < prepareFlushResult.flushOpSeqId) {
                // This should not happen normally. However, lets be safe and guard against these cases
                // we received a flush commit with a smaller seqId than what we have prepared
                // we will pick the flush file up from this commit (if we have not seen it), but we
                // will not drop the memstore
                LOG.warn(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker with smaller seqId: " + flush.getFlushSequenceNumber() + " than what we have prepared with seqId: " + prepareFlushResult.flushOpSeqId + ". Picking up new file, but not dropping" + "  prepared memstore snapshot");
                replayFlushInStores(flush, prepareFlushResult, false);
                // snapshot is not dropped, so memstore sizes should not be decremented
                // we still have the prepared snapshot, flushing should still be true
            } else {
                // This should not happen normally. However, lets be safe and guard against these cases
                // we received a flush commit with a larger seqId than what we have prepared
                // we will pick the flush file for this. We will also obtain the updates lock and
                // look for contents of the memstore to see whether we have edits after this seqId.
                // If not, we will drop all the memstore edits and the snapshot as well.
                LOG.warn(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker with larger seqId: " + flush.getFlushSequenceNumber() + " than what we have prepared with seqId: " + prepareFlushResult.flushOpSeqId + ". Picking up new file and dropping prepared" + " memstore snapshot");
                replayFlushInStores(flush, prepareFlushResult, true);
                // Set down the memstore size by amount of flush.
                this.decrMemStoreSize(prepareFlushResult.totalFlushableSize.getMemStoreSize());
                // Inspect the memstore contents to see whether the memstore contains only edits
                // with seqId smaller than the flush seqId. If so, we can discard those edits.
                dropMemStoreContentsForSeqId(flush.getFlushSequenceNumber(), null);
                this.prepareFlushResult = null;
                writestate.flushing = false;
            }
            {
                if (readsEnabled && !this.writestate.readsEnabled) {
                    LOG.info("Enabling reads for {}", getRegionInfo().getEncodedName());
                }
                this.writestate.setReadsEnabled(readsEnabled);
            }
            // If we were waiting for observing a flush or region opening event for not showing
            // partial data after a secondary region crash, we can allow reads now. We can only make
            // sure that we are not showing partial data (for example skipping some previous edits)
            // until we observe a full flush start and flush commit. So if we were not able to find
        } else {
            LOG.warn(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker with seqId:" + flush.getFlushSequenceNumber() + ", but no previous prepared snapshot was found");
            {
                for (StoreFlushDescriptor storeFlush : flush.getStoreFlushesList()) {
                    byte[] family = storeFlush.getFamilyName().toByteArray();
                    HStore store = getStore(family);
                    if (store == null) {
                        LOG.warn(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker from primary, but the family is not found." + "Ignoring StoreFlushDescriptor:" + storeFlush);
                        continue;
                    }
                    List<String> flushFiles = storeFlush.getFlushOutputList();
                    StoreFlushContext ctx = null;
                    long startTime = EnvironmentEdgeManager.currentTime();
                    if (prepareFlushResult == null || prepareFlushResult.storeFlushCtxs == null) {
                        ctx = store.createFlushContext(flush.getFlushSequenceNumber(), FlushLifeCycleTracker.DUMMY);
                    } else {
                        ctx = prepareFlushResult.storeFlushCtxs.get(family);
                        startTime = prepareFlushResult.startTime;
                    }
                    if (ctx == null) {
                        LOG.warn(getRegionInfo().getEncodedName() + " : " + "Unexpected: flush commit marker received from store " + Bytes.toString(family) + " but no associated flush context. Ignoring");
                        continue;
                    }
                    // replay the flush
                    ctx.replayFlush(flushFiles, dropMemstoreSnapshot);
                    // Record latest flush time
                    this.lastStoreFlushTimeMap.put(store, startTime);
                }
            }
            // There is no corresponding prepare snapshot from before.
            // Inspect the memstore contents to see whether the memstore contains only edits
            // with seqId smaller than the flush seqId. If so, we can discard those edits.
            dropMemStoreContentsForSeqId(flush.getFlushSequenceNumber(), null);
        }
        status.markComplete("Flush commit successful");
        // Update the last flushed sequence id for region.
        this.maxFlushedSeqId = flush.getFlushSequenceNumber();
        // advance the mvcc read point so that the new flushed file is visible.
        mvcc.advanceTo(flush.getFlushSequenceNumber());
    } catch (FileNotFoundException ex) {
        LOG.warn(getRegionInfo().getEncodedName() + " : " + "At least one of the store files in flush: " + TextFormat.shortDebugString(flush) + " doesn't exist any more. Skip loading the file(s)", ex);
    } finally {
        status.cleanup();
        writestate.notifyAll();
    }
}

// check whether we have the memstore snapshot with the corresponding seqId. Replay to
// secondary region replicas are in order, except for when the region moves or then the
// region server crashes. In those cases, we may receive replay requests out of order from
// the original seqIds.
synchronized (writestate) {
    try {
        if (flush.getFlushSequenceNumber() < lastReplayedOpenRegionSeqId) {
            LOG.warn(getRegionInfo().getEncodedName() + " : " + "Skipping replaying flush event :" + TextFormat.shortDebugString(flush) + " because its sequence id is smaller than this regions lastReplayedOpenRegionSeqId " + " of " + lastReplayedOpenRegionSeqId);
            return;
        }
        if (writestate.flushing) {
            PrepareFlushResult prepareFlushResult = this.prepareFlushResult;
            if (flush.getFlushSequenceNumber() == prepareFlushResult.flushOpSeqId) {
                if (LOG.isDebugEnabled()) {
                    LOG.debug(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker with seqId:" + flush.getFlushSequenceNumber() + " and a previous prepared snapshot was found");
                }
                // This is the regular case where we received commit flush after prepare flush
                // corresponding to the same seqId.
                replayFlushInStores(flush, prepareFlushResult, true);
                // Set down the memstore size by amount of flush.
                this.decrMemStoreSize(prepareFlushResult.totalFlushableSize.getMemStoreSize());
                this.prepareFlushResult = null;
                writestate.flushing = false;
            } else if (flush.getFlushSequenceNumber() < prepareFlushResult.flushOpSeqId) {
                // This should not happen normally. However, lets be safe and guard against these cases
                // we received a flush commit with a smaller seqId than what we have prepared
                // we will pick the flush file up from this commit (if we have not seen it), but we
                // will not drop the memstore
                LOG.warn(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker with smaller seqId: " + flush.getFlushSequenceNumber() + " than what we have prepared with seqId: " + prepareFlushResult.flushOpSeqId + ". Picking up new file, but not dropping" + "  prepared memstore snapshot");
                replayFlushInStores(flush, prepareFlushResult, false);
                // snapshot is not dropped, so memstore sizes should not be decremented
                // we still have the prepared snapshot, flushing should still be true
            } else {
                // This should not happen normally. However, lets be safe and guard against these cases
                // we received a flush commit with a larger seqId than what we have prepared
                // we will pick the flush file for this. We will also obtain the updates lock and
                // look for contents of the memstore to see whether we have edits after this seqId.
                // If not, we will drop all the memstore edits and the snapshot as well.
                LOG.warn(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker with larger seqId: " + flush.getFlushSequenceNumber() + " than what we have prepared with seqId: " + prepareFlushResult.flushOpSeqId + ". Picking up new file and dropping prepared" + " memstore snapshot");
                replayFlushInStores(flush, prepareFlushResult, true);
                // Set down the memstore size by amount of flush.
                this.decrMemStoreSize(prepareFlushResult.totalFlushableSize.getMemStoreSize());
                // Inspect the memstore contents to see whether the memstore contains only edits
                // with seqId smaller than the flush seqId. If so, we can discard those edits.
                dropMemStoreContentsForSeqId(flush.getFlushSequenceNumber(), null);
                this.prepareFlushResult = null;
                writestate.flushing = false;
            }
            // If we were waiting for observing a flush or region opening event for not showing
            // partial data after a secondary region crash, we can allow reads now. We can only make
            // sure that we are not showing partial data (for example skipping some previous edits)
            // until we observe a full flush start and flush commit. So if we were not able to find
            // a previous flush we will not enable reads now.
            this.setReadsEnabled(true);
        } else {
            LOG.warn(getRegionInfo().getEncodedName() + " : " + "Received a flush commit marker with seqId:" + flush.getFlushSequenceNumber() + ", but no previous prepared snapshot was found");
            // There is no corresponding prepare snapshot from before.
            // We will pick up the new flushed file
            replayFlushInStores(flush, null, false);
            // Inspect the memstore contents to see whether the memstore contains only edits
            // with seqId smaller than the flush seqId. If so, we can discard those edits.
            dropMemStoreContentsForSeqId(flush.getFlushSequenceNumber(), null);
        }
        status.markComplete("Flush commit successful");
        // Update the last flushed sequence id for region.
        this.maxFlushedSeqId = flush.getFlushSequenceNumber();
        // advance the mvcc read point so that the new flushed file is visible.
        mvcc.advanceTo(flush.getFlushSequenceNumber());
    } catch (FileNotFoundException ex) {
        LOG.warn(getRegionInfo().getEncodedName() + " : " + "At least one of the store files in flush: " + TextFormat.shortDebugString(flush) + " doesn't exist any more. Skip loading the file(s)", ex);
    } finally {
        status.cleanup();
        writestate.notifyAll();
    }
}
possible Hot2
possible type Hot3_2
1
