looking:pipeline
CompactionPipeline	flattenOneSegment
-----------------------
synchronized (pipeline) {
    if (requesterVersion != version) {
        LOG.warn("Segment flattening failed, because versions do not match");
        return false;
    }
    int i = -1;
    for (ImmutableSegment s : pipeline) {
        i++;
        if (s.canBeFlattened()) {
            // to ensure all updates preceding s in-memory flush have completed
            s.waitForUpdates();
            if (s.isEmpty()) {
                // after s.waitForUpdates() is called, there is no updates pending,if no cells in s,
                // we can skip it.
                continue;
            }
            // size to be updated
            MemStoreSizing newMemstoreAccounting = new NonThreadSafeMemStoreSizing();
            ImmutableSegment newS = SegmentFactory.instance().createImmutableSegmentByFlattening((CSLMImmutableSegment) s, idxType, newMemstoreAccounting, action);
            replaceAtIndex(i, newS);
            if (region != null) {
                // Update the global memstore size counter upon flattening there is no change in the
                // data size
                MemStoreSize mss = newMemstoreAccounting.getMemStoreSize();
                region.addMemStoreSize(mss.getDataSize(), mss.getHeapSize(), mss.getOffHeapSize(), mss.getCellsCount());
            }
            LOG.debug("Compaction pipeline segment {} flattened", s);
            return true;
        }
    }
}
-----------------------
synchronized (pipeline) {
    if (requesterVersion != version) {
        LOG.warn("Segment flattening failed, because versions do not match");
        return false;
    }
    int i = -1;
    for (ImmutableSegment s : pipeline) {
        i++;
        if (s.canBeFlattened()) {
            // to ensure all updates preceding s in-memory flush have completed
            s.waitForUpdates();
            if (s.isEmpty()) {
                // after s.waitForUpdates() is called, there is no updates pending,if no cells in s,
                // we can skip it.
                continue;
            }
            // size to be updated
            MemStoreSizing newMemstoreAccounting = new NonThreadSafeMemStoreSizing();
            ImmutableSegment newS = SegmentFactory.instance().createImmutableSegmentByFlattening((CSLMImmutableSegment) s, idxType, newMemstoreAccounting, action);
            replaceAtIndex(i, newS);
            if (region != null) {
                // Update the global memstore size counter upon flattening there is no change in the
                // data size
                MemStoreSize mss = newMemstoreAccounting.getMemStoreSize();
                region.addMemStoreSize(mss.getDataSize(), mss.getHeapSize(), mss.getOffHeapSize(), mss.getCellsCount());
            }
            LOG.debug("Compaction pipeline segment {} flattened", s);
            return true;
            {
                return readOnlyCopy.isEmpty();
            }
            {
                pipeline.set(idx, newSegment);
                readOnlyCopy = new LinkedList<>(pipeline);
                // the version increment is indeed needed, because the swap uses removeAll() method of the
                // linked-list that compares the objects to find what to remove.
                // The flattening changes the segment object completely (creation pattern) and so
                // swap will not proceed correctly after concurrent flattening.
                version++;
            }
        }
    }
}-----------------------
possible Hot2
possible type Hot3_2
1
